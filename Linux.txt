http://ru.opensuse.org/VirtualBox
HAL (Hardware Abstraction Level) - слой абстрагирования (нужен для того чтобы ОС могла работать с любым железом)
dbus - шина по которой интерфейс ОС общался с HAL
udev - менеджер устройств linux (похож на plug in play) м. динамически удалять и устанавливать у-ва
|- знак пайплайн pipline
Кирилл Семаев : или вот понятней ссылка: http://inflin.narod.ru/lin/lin13.htm  (но верхняя подробней)
manage-bde X: -lock
manage-bde X: -unlock –password
Кирилл Семаев : Конфигурация компьютера\Административные шабло-ны\Компоненты Windows\Шифрование диска BitLocker.
Выделите элемент «Диски операционной системы» и дважды щелкните на политике «Требовать дополнительной аутентификации при запуске» (Require Additional Authentication at Startup). Настраиваем его (allow bitlocker without compatible TPM)
Cipher /E C:\Test.txt
Cipher /D C:\Test.txt
uptime - как долго запущена система
папка lost+found создается на томах диска
ctrl+alt+t запуск терминала в граф. среде
apt-cache search делаем поиск пакета связанный с названием

КОММАНДЫ ФИЛЬТРАЦИИ И ВЫВОДА НА ЭКРАН
=====================================
clear - очистить экран

CAT - для объединения ф-лов и печати на стандартный вывод
вывод 2-х ф-лов на экран:
cat hello1.txt hello2.txt
объеденить 2 ф-ла и вывести в третий:
cat hello1.txt hello2.txt > hello3.txt

CUT - удаляет секции из каждой строчки файла
вырезать 2,3,5 символы в ф-ле hello1.txt:
cut -c 2,3,5 hello1.txt

EXPAND - заменяет символы табуляции на пробелы
UNEXPAND - заменяет пробелы в табы

FMT - форматирует вывод текста
игнорирует все символы переноса каретки в файле(если просто без ключа):
fmt hallo1.txt
форматирование текста, чтобы в одной строке было не более 5 символов (переносы меняет на пробелы, если строка 2 сим. - не трогает)
fmt -w 5 hello1.txt

HEAD - показывает первую часть ф-лов
без ключа показывает первые 10 строк:
head hello1.txt
показать первые 2 строчки:
head -n 2 hello1.txt

OD - превращает вывод файлов в другие форматы
без ключей конвертирует вывод в восьмеричный код:
od hello1.txt
в символы asci:
od -c hello1.txt

JOIN - объединяет строчки файлов по общему полю

LESS - позволяет постранично читать ф-л (нажимая PageDown), выполнять поиск
less hello1.txt
просмотреть системный журнал отфильтровав по слову semaev постранично:
grep semaev /var/log/auth.log | less

NL - нумерует строки
nl hello1.txt

PASTE - позволяет построчно вставлять в файл (одна строка из одного и другого, 2-я стр. из одного и др.)
paste 1.txt 2.txt

PR - показывает как будет выглядить текст при выводе на печать

SED - потоковый редактор вывода для фильтрации и трансформации текста
редактировать/edit(ключ -е) заменить/substitute (аргумент s) 'socks' на слово 'peaple' в ф-ле 2.txt:
sed -e 's/socks/peaple/' 2.txt
заменить оо на аа:
sed -e 's/oo/aa/' 2.txt
тоже самое, но уже с сохранением вывода в ф-л 3.txt:
sed -e 's/oo/aa/' 2.txt > 3.txt
ключ -re используя регулярные выражения
заменить если строка начинается с B или b, то заменить на С:
sed -re 's/^(B|b)/C/' 1.txt
 
SORT - сортирует строки в текст. ф-лах по к-нибудь признаку
без ключа по алфавиту, с ключем -r в обратном порядке

SPLIT - делит вывод файла на куски
разделить файл 1.txt на ф-лы содержащие по 2 строчки (ключ -l) исходного ф-ла:
split -l 2 1.txt
создались 2 файла xaa и xab (в каждом по 2 строчки)
разделить по размеру 5 байт (ключ -b):
split -b 5 1.txt
появилось 4 файла xaa,xab,xac,xad

TAIL - показывает последнюю часть файла
без ключей - часть лога на лист
последние 5 записей:
tail -n 5 hello1.txt
посмотреть системный журнал отфильтровав по слову semaev последнюю строчку:
grep semaev /var/log/auth.log | tail -n 1

TR - переводит или удаляет символы
трансформирует у Hello заглавные буквы в прописные (ключ -t трансформировать):
echo Hello | tr -t A-Z a-z
hello
превратить l в L:
echo Hello | tr -t l L
HeLLo
удалить букву l (ключ -d):
echo Hello | tr -d l
Heo
объеденить соседние буквы l:
echo Hello | tr -s l
Helo

UNIQ - ищет уникальные и дублирующиеся строки
покажет уникальные строчки:
uniq 1.txt
покажет количество повторений строчки (пишет рядом число повторений):
uniq -c 1.txt
покажет только дублирующиеся строчки:
uniq -d 1.txt
покажет только неповторяющиеся строчки:
uniq -u 1.txt

WC (work count)- показывает кол-во строк, слов, байт в файле

wc 1.txt
вывод в виде (строк слов байт имя ф-ла):
4 8 29 1.txt
покажи только количество слов (ключ -w):
8 1.txt
вывод информации по всем ф-лам текущего каталога:
wc *
----------------------------------------------------------------------------

РАБОТА С ФАЙЛАМИ И ДИРРЕКТОРИЯМИ
================================

TOUCH - меняет отметки времени файла
Можно создавать пустые ф-лы и менять время доступа к ф-лу
создать пустой файл:
touch 1.txt

MKDIR - создать папку
ls -l - расширенный вывод (списком) содержимого папки
ls * - покажет все, включая вложения
ls *.* - покажет файлы которые имеют расширения
ls [ab]* - покажет все что начинается с а или b
ls [!a-m]* - покажет все, кроме файлов начинающихся с a по m

CP - копирование ф-лов, папок
скопировать файл:
cp 1.txt cop1.txt
скопировать папку с содержимым (ключ -R)в др. папку:
cp -R folder1 folder2
скопировать архив 1.zip в папку folder 2
cp 1.zip "Folder 2"/1.zip

MV - перенос, переименование ф-лов
перенести ф-л из папки folder1 в текущий каталог:
mv folder1/1.txt .

RM - удаляет файлы и папки
rm 1.txt - удалить файл 1.txt
удалить папку с содержимым (ключ -r) игнорируя предупреждения (ключ -f)
rm -rf folder1

RMDIR - удаляет пустые папки

FILE - определяет тип файла
например:
file 14.jpg
14.jpg: JPEG image data, EXIF standart
расскажет про все ф-лы в папке:
file *

FIND - поиск файлов в директории
найти все в текущем каталоге:
find .
найти все в тек. каталоге у чего имя (ключ -name) начинается с 'In':
find . -name "In*"
найти все что начинается с заглавной буквы и имеет расширение:
find . -name "[A-Z]*.*"
найти все, что > 5 МБайт:
find . -size +5M
найти все, что < 5 МБайт:
find . -size -5M
найти все, что имеет тип файл 
find . -type f
найти все, что имеет тип директория 
find . -type d
найти все, к чему мы имели доступ (ключ -atime) access time не раньше чем 5 дней:
find . -atime +5
найти все, что изменялось (ключ -ctime) change time не раньше чем 5 дней:
find . -ctime +5

grep	- утилита поиска (м.б. с ключем -e -f -r);
egrep	- расширенный grep (понимает сложные);
fgrep	- быстрый grep (не понимает рег. выражений);
rgrep	- рекурсивный grep (ищет во вложенных ф-лах и папках);
sed	- потоковый текстовый редактор.

найти сочетание оо в содержимом ф-ла 1.txt:
grep oo 1.txt
тоже самое с нумерацией строк:
grep -n oo 1.txt
тоже самое без чувствительности к регистру (по умолчанию чувствителен)
grep -i oo 1.txt
ищет в списке ф-лов названия с сочетанием ile:
ls | grep ile
ищет в содержимом ф-ла:
cat1.txt | grep ile

АРХИВИРОВАНИЕ
=============
CPIO - двоичный архиватор
взять все из текущей папки и положить (ключ -o) на уровень выше (> ..) и создать файл архива test.cpio:
ls | cpio -o > ../test.cpio
собрать все ф-лы *.txt в архив test2.cpio:
find . -name "*.txt" | cpio -o > test2.cpio
взять все из архива test2.cpio находящегося на уровень выше:
cpio -id < ../test2.cpio

DD - конвертирует и копирует ф-лы
скопировать диск (вместе с разделами) /dev/sdb (input file) в образ диска disk1.img (output file):
dd if=/dev/sdb of=disk1.img

GZIP (GNU ZIP) - архиватор
сделать архив образа disk1.img:
gzip disk1.img
преобразует ф-л в disk1.img.gz
распаковать ф-л из этого архива:
gunzip disk1.img.gz
преобразует ф-л в disk1.img

BZIP2 - архиватор (лучше сжимает)
сделать архив образа disk1.img:
bzip2 disk1.img
преобразует ф-л в disk1.img.bz2
распаковать ф-л из этого архива:
bunzip2 disk1.img.bz2
преобразует ф-л в disk1.img

XZ - архиватор
сделать архив образа disk1.img:
xz disk1.img
преобразует ф-л в disk1.img.xz
распаковать ф-л из этого архива:
unxz disk1.img.xz
преобразует ф-л в disk1.img

TAR - архиватор
создать ф-л архива archive.tar из папки folder
(create verbose(процесс) file):
tar cvf archive.tar folder
рядом с папкой создается архив с именем archive.tar

создать ф-л архива используя архиватор gzip:
tar cvfz archive.tar.gz folder 
рядом с папкой создается архив с именем archive.tar.gz

распаковать архив archive.tar:
tar xvf archive.tar

--------------------------------------

ГРУППОВЫЕ СИМВОЛЫ
=================
* - все что угодно
? - любой символ
! - не
[ac] - а или с
[a-c] - a,b,c
-----------------

РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ
====================
\<text	- слова начинающиеся с text;
text\>	- слова заканчивающиеся на text;
^	- начало строки;
$	- конец строки;
[a-z]	- диапазон от а до z;
[^t]	- не буква t;
\[	- воспринять символ [ буквально;
.	- любой символ;
a|z	- a или z.

ищет сочетания ple в файле 1.txt:
grep ple 1.txt
ищет сочетание ple в начале строк ф-ла 1.txt:
grep ^ple 1.txt
ищет сочетание ple в конце строк ф-ла 1.txt:
grep ple$ 1.txt
поиск условия: в начале строки начиналось с b или d:
egrep '^(b|d)' 1.txt

выполнение команд:
выполняет команды одну за другой:
команда1;команда2
выполняет команду2, если команда1 была выполнена успешно:
команда1&&команда2
выполняет команду2, если команда1 возвращает ошибку:
команда1||команда2
запускает команду в фоновом режиме:
команда&
выполняет обе команды в одной и той же оболочке:
(команда1;команда2)

механизмы подстановки в bash:
любой символ:
?
любое количество любых символов (в т.ч. ни одного), но не *-файлы:
*
любые файлы и каталоги, в т.ч. из всех подкаталогов:
**
один из символов, указанных в скобках:
[abc]
символ из указанного диапазона:
[a-f]
любые символы, кроме тех, что указаны в скобках:
[!abc]
аналогично предыдущему:
[^abc]
сокращенное обозначение домашнего каталога:
~
текущий каталог:
.
каталог на один уровень выше:
..
возвращает ab1 ab2 ab3:
ab{1,2,3}
возвращает а1 а2 а3 а4:
a{1..4}
арифметические вычисления:
$[3*4]
замена команды результатом ее выполнения:
`команда`
вариант аналогичный предыдущему:
$(команда)
Последовательность символов  [a,b,e-h]*  означает файлы, имена которых начинаются с
a ,  b ,  e ,  f ,  g  или  h . Если первый символ, указанный в квадратных скобках, - это
^  или  ! , то допустимы все символы, кроме указанных в скобках.
отдельно стоящий дефис ( - ) означает любой спецсимвол.

чтобы разбить команду на 2 строки исп-ся "\"

вызов справки:
команда -help
man команда
help команда
info команда

ПОТОКИ КОНВЕЙРЫ И ПЕРЕНАПРАВЛЕНИЯ ВВОДА И ВЫВОДА
================================================
Stdin(0) - стандартный ввод;
Stdout(1) - стандартный вывод;
Stderr(2) - стандартный вывод ошибки;
> - передать в;
>> - дописать в;
< - взять из;
| - отправить следующей команде;
Tee - отправить в файл и на стандартный вывод;
Xargs - построчнопередать на вывод команде;

отправить результат ошибки выполнения команды ls (2) в файл result.txt (ф-ла bob не существует):
ls bob 2> result.txt
в файле появится "ls:невозможно получить доступ к bob: нет такого ф-ла или каталога"
отправить результат выполнения команды ls (1-использ-ся по умолчанию) в файл result.txt (если ф-л bob существует):
ls bob 1> result.txt
вывести результат работы команды в ф-л result.txt, а если возникнут ошибки - в ф-л error.txt:
ls bob > result.txt 2> error.txt

КОНВЕЙР ПЕРЕДАЧИ РЕЗУЛЬТАТА КОМАНД
===================================
выбрать в списке файлы с буквой "r":  
ls | grep r
отправить вывод списка на экран и в файл:
ls | tee output.txt
построчное выполнение результата команды делает xargs
например найти текстовые ф-лы и их удалить:
find . -name "*.txt" | xargs rm -f

РАБОТА С ПАРАЛЛЕЛЬНЫМИ ПРОЦЕССАМИ
=================================
бездействие 1000сек.
sleep 1000
бездействие 1000сек. в фоновом процессе:
sleep 1000 &
покажет
[1] 2215
(можно остановить процесс ctrl+Z)
выполняемые процессы:
jobs
покажет
[1]+ Выполняется sleep 1000 &
[2]- Остановлено sleep 1000
перейти к фоновому процессу foreground (в данн. случае 2):
fg 2
вновь запустить фоновый процесс 1 background:
bg 1
ps - snapshot текущего состояния процессов
ключ -eo выводить выбранные столбцы
ps -eo user,pid,pcpu(цпу),nice(приоритет),comm(описание)
ключ aux (all user x (executable)-видеть даже те процессы, кот. были запущены вне нашего терминала)
ключ alx (l-list) -подробный список, где колонка NI (nice) - приоритет процесса (-20 максимальный +19 минимальный)
например вывести только процессы sleep:
ps aux | grep sleep

убиваются процессы ком. kill id_процесса:
kill 2215
завершить все процессы с именем sleep:
killall sleep
exit - закрыть терминал
При завершении сессии все запущенные процессы прервутся, чтобы они не завершались есть
программа nohup:
nohup sleep 1000 &
покажет:
nohup: ввод игнорируется, вывод добавляется в "nohup.out"
pstree - показывает иерархический снимок процессов
pgrep - поиск и вывод процессов
найти все проц. с именем sleep:
pgrep sleep
покажет только id процессов
покажет id и имя процесса:
pgrep sleep -l
покажет все процессы пользователя semaev:
pgrep -u semaev -l
pkill завершает процессы
завершить процессы с именем sleep:
pkill sleep
top - диспетчер задач в реальном времени
+- сортировка
по умолчанию сортирует по загрузке процессора.
Чтобы завершить к-либо процесс нажимаем "k" и вводим номер процесса
по умолчанию предлагает завершаить процесс с сигналом 15 (sigterm) (мягкое завершение).
Вводим 15
завершаить процесс с сигналом 9 (sigkill) (жесткое завершение)
q - выход из программы
uptime - показывает как долго запущена система, а также load average (3 цифры)
1-я - загрузка в посл. минуту
2-я - загрузка в посл. 5 минут
3-я - загрузка в посл. 15 мин.
screen - запустить еще одно работающее окно в пределах одного терминала
поработать в нем, затем нажать
Ctrl+A после чего нажать D. Это как бы свернет окно.
Чтобы вернуться к скрину нужно набрать screeen -r
Чтобы завершить скрин набираем exit.
Если хотим создать неск. окон, нужно создать для них псевдонимы:
например в отдельном окне пустим пинг:
screen -S yandex ping ya.ru
посмотреть запущенные скрины:
screen -ls
перейти к скрину:
screen -r yandex

установить минимальный приоритет процесса:
nice -n 19 sleep 2000 &
установить максимальный приоритет процесса:
nice -n -20 sleep 2000 &
проверяем:
ps -eo user,pid,nice,comm | grep sleep
переустановить приоритет действующему процессу:
renice 5 -p 2572
покажет
2572 (идентификатор процесса) старый приоритет 19, новый приоритет 5
изменить приоритет задач для пользователя semaev:
renice 15 -u semaev

имеющаяся в распоряжении память:
free
информация о состоянии систем IDE и SCSI и всех связанных с ними устройств:
lsscsi
информация о компонентах pci:
lspci
подробный (verbose) список всех USB-интерфейсов и устройств (пакет  usbutils):
lsusb -v
-------------------------------
Если команда  unmount  возвращает ошибку
Device is busy  (Устройство занято), это означает, что данные с CD-ROM использу-
ются другой программой. Такая реакция возникает и в том случае, если какой-ли-
бо из каталогов диска открыт в одной из оболочек. Выполните в нем команду  cd ,
чтобы перейти в домашний каталог. Если требуется найти процесс, из-за которо-
го возникает такая ошибка, воспользуйтесь командой  fuser  - выполните  fuser -m
/cdrom 
-------------------------------


TAR
===
Архивы, запакованные с помощью программы  gzip , обычно имеют расширения
*.tgz  или  *.tar.gz . Архив устанавливается на компьютере благодаря программе  tar.
Отображение содержимого архива:
tar -tzf archiv.tar.gz
Распаковка файлов относительно текущего каталога:
tar -xzf archiv.tar.gz 
Распаковка в один каталог:
tar -xzf archiv.tar.gz -C dir




TOP
===
top - диспетчер процессов (для выхода нажать Q)
-------------------
Команда  top  обладает способностью интерактивного приема команд. При этом
процессы можно останавливать ( K  - kill ) или изменять их приоритет ( R )
-------------------
Процессы могут находиться в различных состояниях. Чаще всего встречаются
состояния  R  (running)  и  S  (sleeping, то есть сейчас процесс не выполняет никаких
задач и ожидает ввода информации). Кроме того, выполнение программы можно
временно прервать, переведя ее в состояние  T  (stopped).
-------------------
В столбце  PID  указаны номера процессов. Зная номер процесса, можно прину-
дительно остановить вышедшие из-под контроля программы или фоновые про-
цессы с помощью команды  kill .
-------------------
Когда вы знаете названия программ и хотите
выяснить соответствующий программе номер процесса (PID), поможет команда pidof:
pidof программа
-------------------
Можно завершать процессы и с помощью команды  top : просто
нажмите клавишу  K  и дополнительно - номер процесса, а также желаемый сигнал.


KILL
====
Эта команда посылает действующему процессу сигналы, специфи-
цируемые благодаря номеру  PID  (его можно узнать с помощью команды  top  или  ps ).
Чтобы «аккуратно» завершить программу, используется сигнал 15 ( kill  задейству-
ет этот сигнал по умолчанию). Если это не помогает, необходимо применить сигнал 9
(в данном случае - для процесса 2725):
kill -92725


KILLALL
=======
Эта команда гораздо удобнее, так как при ее использовании
можно указывать не номер процесса, а название программы. Правда, в данном
случае будут завершены все процессы с таким именем:
killall -9 firefox



показывает свободное место для всех сегментов ф-ловой системы:
df -h
сколько дискового пространства требует каталог, включая подкаталоги (-h удобочитаемость):
du -h

rm –rf windows удаление со всем содержимым


CP
==
копирование каталога вместе со всем содержимым (рекурсия):
cp -r
если надо сохранить информацию о правах при копировании:
cp -a
копирует все C-файлы из каталога  project  в текущий каталог:
cp project/*.c .
бэкап всех файлов каталога /etc:
cp -a /etc/* /etc-backup

Можно проверить работу с джокерными символами командой  echo jokerzeichen . Она показывает все
имена файлов, охватываемые комбинацией с джокерным символом, и выводит эти
имена на экран, не изменяя при этом имен файлов.

grep Поиск текста в текстовом файле
find Поиск файлов по имени, дате, размеру и т. д.
locate Поиск файлов по имени


FIND
====
Следующая команда ищет все файлы в текущем каталоге и во всех подкаталогах,
названия которых начинаются с  .e :
find -name '.e*'
--------------------------
Команда  find  производит поиск, начиная с каталога  /usr/share/texmf , и ищет все
файлы вида  *.tex  в каталоге, название которого оканчивается на  latex:
find /usr/share/texmf -path '*latex/*.tex'
--------------------------
Ищет все каталоги, находящиеся в  /etc/ . Обычные
файлы, располагающиеся в  /etc/. , среди результатов не показываются. Список
результатов упорядочивается по алфавиту с помощью команды  sort  (по умолчанию
такой сортировки не происходит).
find /etc -type d | sort
--------------------------
Ищет все файлы в (под)каталогах  /home , принадле-
жащих пользователям группы  users , причем искомые файлы должны были каким-
либо образом быть изменены в течение последних пяти дней (содержание, права
доступа и т. д.):
find /home -group users -mtime -5
--------------------------
Команда  find -mtime +5  находит такие файлы, которые были изменены ранее,
чем пять дней назад, а команда  -mtime 5  возвращает файлы, которые были измене-
ны ровно пять дней назад. 
--------------------------
Следующая команда удаляет все резервные копии, содержащиеся в данном
каталоге и во всех подкаталогах. При этом  find  строит список всех сомнительных
файлов и передает его команде  rm  через подстановку команды  ($(команда)):
rm $(find . -name '*~')
--------------------------
Следующая команда показывает,как выполнить поиск файлов,
в названиях которых содержится последовательность
символов  abcde , в  /etc  и во всех его подкаталогах:
find -type f -exec grep -q abcde {} \; -print

GREP
====
Следующая команда просматривает все TEX-файлы текущего каталога в поис-
ках последовательности символов  emacs . Список всех найденных строк (перед
каждой из которых указывается имя файла) отображается на экране:
grep emacs *.tex
--------------------------
Команда  grep  с параметром  -v  возвращает в качестве результата все строки,
в которых отсутствует заданный шаблон поиска.
--------------------------
Удаляет из  configfile  все строки, которые
начинаются с символа  #  (то есть все комментарии). Следующая команда  cat  до-
полнительно удаляет все пустые строки. Конечный результат сохраняется в файле
nocomments:
grep -v '^#' configfile | cat -s > nocomments  
--------------------------
В следующем примере команда  grep  отфильтровывает из списка всех установленных пакетов те,
в которых содержится последовательность символов  mysql  без учета регистра.
Команда  sort  сортирует полученный список:
rpm -qa | grep -i mysql | sort

CAT
====
слияние и вывод файлов на экран



/sbin
stat mount.cifs свойства
chmod 4755 mount.cifs
ls просмотр директории
ls - l /windows/myfile.txt просмотр прав доступа
smbclient –L win8 –U username  отобразить ресурсы, предоставленные в общий доступ на windows-машине
Mount –t cifs –o username монтировать сетевую папку


Install-WindowsFeature –Name Failover-Clustering –IncludeManagementTools


http://faqpc.ru/kak-ustanovit-ubuntu-server-14-04-1-lts/

ПО для изменения размера разделов:
resize2fs

shift+вверх/вниз перелистывание в консоли

LS
==
вывод списка ф-лов/папок текущей директории с правами безопасности и датой:
(десять первых символов в начале строки указывают тип файла и биты доступа.
дефис ( - ) для обычного файла,  d  для каталога (directory),
b  или  c  для файла устройства (block или char) или  l  для символьной ссылки.)
ls -l
с отображением скрытых файлов (у которых вначале точка):
ls -a
сортировка по времени:
ls -t
по размеру:
ls -S
по расширению:
ls -X
сортировка в обратном порядке:
ls -r
с отображением ф-лов в подкаталогах:
ls -R
пример комбинации параметров:
ls -laR
постраничный показ ф-ла:
less файл
постраничный показ каталога:
ls -l | less
для одновременного вывода на экран и записи в ф-л исп. команда tree:
ls | tree файл
Вывод в файл1 (обычно отсортирован). Копия вывода передается sort, а затем
происходит сортировка по размеру ф-ла (5-й столбец, т.е. +4) и сохраняет в файл2:
ls -l | tree файл1 | sort +4 > файл2
--------------------------------------------------------------------------------
 
ПРАВА ДОСТУПА К ФАЙЛУ
=====================
девять битов доступа ( rwxrwxrwx  для  read/write/execute  - для владельца файла,
членов группы владельца и всех остальных)
-----------------------------
Если  michael  пожелает, чтобы этот файл был доступен для чтения только поль-
зователям группы  users  и был недоступен для пользователей, не входящих в эту
группу, нужно будет деактивировать последний  r -бит. Для этого применяется
команда  chmod:
michael$ chmod o-r  файл .txt
michael$ ls  файл .txt -l
-rw-r----- 1 michael users 3529 Oct 4 15:43 файл.txt
-----------------------------
Необходимо добавить "только чтение" для группы пользователей dokuteam.
Дополнительно изменяем групповую отнесенность
с помощью команды  chgrp :
michael$ chgrp dokuteam  файл .txt
michael$ ls  файл .txt -l
-rw-r----- 1 michael dokuteam 3529 Oct 4 15:43 файл.txt
-----------------------------
в восьмеричной системе:
Каждая цифра составляется из величин  4 ,  2  и  1  для  r ,  w  и  x 
соответственно. Таким образом,  660  означает  rw-rw---- ,  777  означает  rwxrwxrwx . Три
специальных бита  Setuid ,  Setgid  и  Sticky  имеют восьмеричные значения  4000 ,  2000 
и  1000
например:
chmod 640  файл .txt
------------------------------
При установки прав доступа к каталогам:
В принципе девять битов доступа применимы и при работе с каталогами, но в таком
случае их значение несколько отличается:  r -бит позволяет другим пользователям
просмотреть содержимое каталога с помощью команды  ls . Кроме того,  x -бит дает
возможность перейти в этот каталог с помощью  cd . Если поставить и  x , и  w , то в ка-
талоге можно создавать новые файлы.
------------------------------
назначение прав:
chmod
chmod 755 mydir (если добавить 1 бит перед цифрами можно запустить любому от имени владельца ф-ла или гр. владельца)
Тут символы есть: u (user) g (group) o (others)
И к правам добавляется бит S (переустановить идентификатор) (или в цифрах – 2 это группа, 4 это пользователь)
например chmod 4755 file.txt запуск от имени владельца ф-ла

ctrl+D выход из режима SU

chown смена владельца
chown user:users mydir смена владельца и группы владельца на папку

СОЗДАНИЕ И ЗАПУСК СКРИПТА
=========================
1.Создать файл с расширением .sh
2.Записать в начало файла:
#!/bin/bash
потом тело скрипта
3.Сделать файл исполняемым:
Для этого введите команду chmod +x и имя файла скрипта
chmod +x hello.sh
4.Теперь запускаем его:
./hello.sh
или
sh hello.sh

MV (переименовать файл)
======================
mv опции файл-источник файл-приемник
опции:
-f — заменять файл, если он уже существует;
-i — спрашивать, нужно ли заменять существующие файлы;
-n — не заменять существующие файлы;
-u — заменять файл только если он был изменен;
-v — вывести список обработанных файлов;
чтобы переименовать достаточно:
mv file newfile

RENAME (переименовать файл, массовое переименование)
==========================
$ rename опции ‘s/старое_имя/новое_имя‘ файлы
или:
$ rename опции старое_имя новое_имя файлы
опции:
-v — вывести список обработанных файлов;
-n — тестовый режим, на самом деле никакие действия выполнены не будут;
-f — принудительно перезаписывать существующие файлы;

например, переименуем все htm файлы из текущей папки в .html:
rename 's\.htm/\.html/' *.htm

модификаторы:
g (Global) — применять ко всем найденным вхождениям;
i (Case Censitive) — не учитывать регистр.

Модификаторы размещаются в конце регулярного выражения, перед закрывающей кавычкой.
Перед тем, как использовать такую конструкцию, желательно ее проверить, чтобы убедиться,
что вы не допустили нигде ошибок, тут на помощь приходит опция -n.
Заменим все вхождения DSC на photo в именах наших фотографий:
rename -n 's/DSC/photo/gi' *.jpeg

Можно использовать не только обычную замену, но и полноценные регулярные выражения чтобы
выполнить пакетное переименование файлов linux, например, переделаем все имена в нижний регистр:
rename 'y/A-Z/a-z/'*.jpeg


посмотреть версию Linux
=======================
cat /proc/version
или
dmesg | grep "Linux version"

Чтобы узнать версию дистрибутива:
lsb_release -a
или
вывести содержимое файлов "*-release", находящихся в директории /etc
cat /etc/*-release
--------------------------------------------------------------------

РАБОТА С BASH
=============
Псевдонимы позволяют запускать команды с к-либо ключами
чтобы добавить псевдоним в пользовательских настройках bash редактируем файл .bashrc в профиле:
vi ~/.bashrc
к примеру будет команда forhowlong:
в конец ф-ла дописываем строку:
alias forhowlong='uptime -p'
выходим и запускаем bash снова, чтобы он применил изменения:
bash

Функция отличается от псевдонима тем, что можно написать к-либо последовательность команд
Создадим ф-ю WTF:
function WTF() {
echo "your name is:";
whoami;
echo "today is:";
date;
echo "you are here:";
pwd;
}

передача аргументов в ф-ю:
создадим ф-ю
передает значение даты в файл с названием 1-го аргумента ф-ии
фильтрует лог по этому аргументу и дозаписывает в это ф-л:
function showlog() {
date > $1.txt;
grep $1 /var/log/auth.log | tail -n 1 >> $1.txt;
}
выходим, перезапускаем bash
пишем:
showlog semaev
проверяем
в файл semaev.txt записалась дата и последняя строчка лога

создадим такую-же ф-ю, только вторым аргументом будет ко-лво считываемых с конца ф-ла строк:
function showlog() {
date > $1.txt;
grep $1 /var/log/auth.log | tail -n $2 >> $1.txt;
}
выходим, перезапускаем bash
пишем:
showlog semaev 3
дополнительно узнать:
http://linuxgeeks.ru/bash-2.htm

переменные:
добавить в переменную PATH еще один путь:
PATH=$PATH:/home/semaev
добавляем эту переменную в переменные среды:
export PATH
проверяем
env

Для редактирования переменных среды у пользователя, редактируем файл:
vi ~/.profile или ~/.bash_profile
---------------------------------------------------------------------

BASH-СКРИПТЫ
============

создадим простой скрипт:
vi script
#!/bin/bash
echo "Are you hungry?"
read VALUE
if [ $VALUE = "YES" ];
then
echo "Make some dinner"
else
echo "Continue working"
#fi-говорит о том, что скрипт будет завершен
fi
Добавляем права на запуск ф-ла:
chmod u+x script
Можем поставить права на запуск скрипта всем пользователям от имени владельца скрипта
(добавим SUID sticky-бит для пользователя):
chmod u+s script

& - и
&& - вополнит следующее действие, если предыдущее справедливо
| (PiPline) - передает значение следующей команде (конвейер)
|| - выполняет следующее действие, если предыдущее не справедливо
-e - справедливо (существует)

запуск программы словом test или условие в []
работа программы test:
может вывести результат работы программы через $?
чтобы увидеть значение результата: echo $?
0 - результат положительный
не 0 - результат отрицательный


test 100 -gt 50 && echo "Yes" || echo "No"
или
if [ -e /home/semaev ];
then
echo "Found it"
else
echo "No semaev in home folders"
fi

Для работы с почтой необходимо установить пакет mailutils
отправить письмо пользователю root:
mail -s "info" root

подстановка:
зададим переменной х значение даты
переменная у получает результат выполнения команды uptime -p:
x=$(date)
y=`uptime -p`
echo " Today is $x and we are $y"

использование циклов:
создадим скрипт loop_for_1
в нем пишем:
#!/bin/bash
for x in 1 3 7
do
echo $x
done

добавляем права исполнения на этот скрипт:
chmod +x loop_for_1
запускаем скрипт:
./loop_for_1
покажет:
1
3
7

можно указать последовательность (seq) от 3 до 8:
for x in `seq 3 8`
do
echo $x
done

передадим переменной значение результата команды ls ~(тильда)
покажет список ф-лов родительской папки пользователя:
files=`ls ~`
for x in $files
do
echo $x
done

пока перем. х не равна 5 выводить значение переменной:
x=1
while [ $x -ne 5 ]
do
echo $x
x=$(($x+1))
done

пока переменная не будет = stop, будет повторять вводимые значения:
echo "Type all you want, or type STOP to stop script"
x="Go"
while [ $x != "STOP" ]
do
read x
echo $x
done


РАБОТА С ЖЕСТКИМ ДИСКОМ
=======================
Посмотреть разделы на диске:
fdisk -l
нумерация дисков 1-4 только для основных разделов, 5 и более для логических
Нумерация последней буквы для физ. дисков (serial drive a,b,c)
/dev/sda, sdb, sdc
начинаем работу с диском sdb:
fdisk /dev/sdb
m - для справки
n - добавление нового раздела
t - поменять тип раздела
L - список кодов типов раздела
p - таблица разделов
w - записать изменения
mkswap - форматирование раздела подкачки:
mkswap /dev/sdb2
swapon - включить раздел подкачки:
swapon /dev/sdb2
посмотреть какие есть разделы подкачки:
swapon -s
выключить раздел подкачки:
swapoff /dev/sdb2
mkfs - строит файловую систему
форматирование под файловую систему (ключ -t тип) ext2:
mkfs -t ext2 /dev/sdb1
чтобы переформатировать в другую файл. систему (напр. xfs) используем ключ -f (force):
mkfs -t xfs -f /dev/sdb1

gdisk - работает с большими дисками GPT (GUID Partition Table)
создадим диск с gpt (или переделаем старый)
gdisk /dev/sdb
выбираем комманду - o
y - записать изменения
n - создать новый раздел
+5GB - выбираем конец первого раздела, через 5 Гб
w - записать изменения

parted - программа работающая со всеми дисками
посмотреть разделы:
parted -l
начинаем работу с диском sdb:
parted /dev/sdb
help - открываем help
q - выход

gparted - таже ПО с граф. оболочкой
---------------------------------------

FDISK
=====
Для просмотра имеющихся дисков, на sata контролере:
ls /dev | grep sd
Если у нас есть созданные разделы, информацию о них можем посмотреть такой командой (sda, sdb,sdc...):
/sbin/fdisk -l /dev/sda
Далее, мы можем переходить к работе с fdisk, для этого вводим команду и в аргументе указываем нужный нам диск, в данном случае «/dev/sda».
fdisk /dev/sda
После чего, попадаем в меню fdisk.
Список доступных командам можно получить введя «m»
Команды:
a   установить/снять флаг загрузочного раздела
b   редактировать метки bsd диска
c   переключить флаг совместности с dos
d   удалить раздел
l   вывести список известных типов разделов
m   показать это меню
n   добавить новый раздел
o   создать новую пустую таблицу разделов в стиле DOS
p   показать существующею таблицу разделов
q   выйти без сохранения изменений
s   создать новый раздел с меткой Sun
t   изменить метку типа раздела
u   изменить отображения/записи блоков
v   проверить таблицу разделов
w   сохранить изменения и выйти
x   дополнительные возможности (только для экспертов)

* Создание разделов fdisk-ом см. файл "linux каталоги"

UUID (это уникальное число тоесть номер раздела жесткого диска)
===============================================================
узнать UUID раздела жесткого диска или какого либо другого блочного устройства:
Листингом в дире с ссылками на устройства:
ls -l /dev/disk/by-uuid/
При помощи специальной утилиты blkid:	
blkid /dev/sda2

Вывод сообщения ядра:
dmesg
Посмотреть лог этих сообщений (соджержит только инф. о загрузке):
cat /var/log/dmesg
Посмотреть дерево процессов:
pstree
-----------------------------------------------------------------

ПРОВЕРКА ФАЙЛОВОЙ СИСТЕМЫ
=========================

inod (номер inod) - идентификатор (местонахождение/метка) ф-ла 
DF (disk free) показывает размер разделов:
df -h
Индексные дискрипторы inods в них хранится информация о владельце, размере, правах доступа ф-лов.
Для каждого файла создается свой inod.
Обычно для их размещение отдается 1% от жесткого диска
показывает кол-во inods, кол-во использованных, кол-во свободных inods для дисков:
df -i

DU (disk usage) показывает что и сколько занимает места
размер папок в текущей директории:
du -h
можно явно указать папку для поиска со вложенными папками:
du -h /home/semaev/*
показывает только один уровень вложения (ключ --summarize):
du -h --summarize /home/semaev/*

показывает размер файлов:
ls -l
показывает номера индексных дискриптеров (inods):
(если восстановить индексный дескриптор после удаления файла - можно восстановить и сам ф-л)
ls -i

FSCK (file system check) проверяет целостность ф-ловой системы
fsck /dev/sdb1
автоматом определяет файл. систему и запускает соотв. программу проверки для этой системы
если не смог определить, то указываем явно:
fsck -t ext4 /dev/sdb1
пишет, что диск смонтирован, вначале нужно отмонтировать:
umount /mnt/hard
папка куда смонтированы диски
повторяем:
fsck -t ext4 /dev/sdb1
монтируем диск обратно:
mount /dev/sdb1 /mnt/hard/

DEBUGFS отладчик файловой системы
с внесением изменений (ключ -w):
debagfs -w /dev/sdb1
вывести содержимое тома (с inods):
debagfs: ls
покажет в формате inod (размер) имя ф-ла
2(12).	2(12).. 11(44)lost+found	12(4028)test.txt
удалить ф-л:
debagfs: rm 1.txt
показать удаленные ф-лы:
debagfs: lsdel
показывает, что есть один удаленный inod под ном. 12
Inode	Owner	Mode	Size	Blocks	Time deleted
12	0	100544	15	1/	1 Mon Jan 19 18:44:12 2015
ideleted inodes found.
восстановить дескриптор удаленного ф-ла и написать желаемое имя восстанавливаемого ф-ла:
undel <12> test.txt

DAMPE2FS делает дамп информации файловых систем ext2/ext3/ext4
вывести на экран дамп диска:
dumpe2fs /dev/sdb1
тоже записать в ф-л:
dumpe2fs /dev/sdb1 > dump.txt
создадим другую ф-ловую систему (можно mkfs, а можно mke2fs):
вначале размонтируем этот диск:
umount /dev/sdb1
создаем:
mke2fs -t ext2 /dev/sdb1
отфильтруем вывод созданного дампа по строке содержащей features:
dumpe2fs /dev/sdb1 | grep features
видим отсутствует информация о журнале

TUNE2FS настроивает настраиваемые параметры файловых систем ext2/ext3/ext4
настроить опцию (ключ-O) иметь журнал (has_journal):
tune2fs -O has_journal /dev/sdb1
превратила fs ext2 в журналируемую
покажет
tune2fs 1.42.9 (4-Feb-2014)
Создание inod'a журнала: done
проверяем
dumpe2fs /dev/sdb1 | grep features
показывает
Filesystem features: has_journal ext_attr resize_inode dir_index и т.д.
Journal features: (done)
т.е. журнал в опциях есть и он пустой
удалить опцию (ключ-O) иметь журнал (has_journal):
tune2fs -O ^has_journal /dev/sdb1
----------------------------------------------------------------------- 
 
МОНТИРОВАНИЕ ФАЙЛОВЫХ СИСТЕМ
============================

посмотрим св-ва диска sdb1:
ls -l /dev/sdb1
посмотрим корень диска:
ls /
монтируем (WINDOWS переводим в онлайн) диск в созданную папку
mount /dev/sdb1 /mnt/hard
команда mount без ключей покажет что смонтировано в системе
отмонтируем диск из системы:
umount /dev/sdb1
перед отмонтированием все программы работающие с ним, открытые ф-лы, должны буть закрыты.
можно отмонтировать все, что примонтировано в папку:
umount /mnt/hard/
файл автоматического монтирования ф-ловых систем: 
cat /etc/fstab
лучше прописывать id устройчтва, но можно и по именам
все параметры прописываются через <tab>
<file system> <mount point> <type> <options> <dump> <pass>
dump - сохранять ли нам файлы автоматом при отключении ОС (внезап.отключение питания) (1-сохранять,0 -не сохранять)
pass - порядок проверки ф-ловых систем (1-у корневой ф-ловой сист."проверка в первую очередь", у всех 
остальных -2, у съемных -0)
запишем:
/dev/sdb1	/mnt/hard	auto	rw,user,auto,noexec	0	2
<type> тип файловой системы можно указать auto
<options> опции можно указать defaults (ф.сист. доступна на чтение/запись, м. находиться исполняемые ф-лы, автоматически монтируется, не может считать пользователь), а можно указать вручную, через запятую
rw (чтение запись),user (любой пользователь м. монтировать и демонтировать),auto (будет автоматически подключать при старте)(noauto - не будет),noexec (никто не сможет запускать исполняемые ф-лы)
<dump> сбрасывать ли при отключении питания информацию указать 0 (не надо)
<pass> тип проверки 2 (указывается для всех файл.систем, кроме корневой)
сохраняем выходим
после можем смонтировать от пользователя указав точку монтирования, а система посмотрит в ф-ле устройство и смонтирует его
mount /mnt/hard/
В десктоповых линуксах монтирование подключаемых устройств происходит автоматом

BLKID показать блочное устройство, можно посмотреть id устройства
blkid - покажет все болчные у-ва в системе
blkid /dev/sdb1
покажет:
/dev/sdb1: UUID="ae86eca-f5cc-4564-a142-187652fb08af" TYPE="ext2"
можем в fstab вместо /dev/sdb1 прописать UUID=ae86eca-f5cc-4564-a142-187652fb08af

Чтобы автомат. монтировался cdrom вначале через blkid смотрим имя устройства, потом прописываем в fstab (ключ ro-read only):
/dev/sr0	/media/cdrom	udf,cdfs,iso9660	user,noauto,exec,ro	0	0
сохраняем, потом монтируем
mount /dev/sr0   

после монтирования флешки, чтобы корректно ее вытащить необходимо вначале ее отмонтировать.
umount имя_устр
потом написать комманду, которая выдергивает флешку eject
--------------------------------------------------------------------------------------------

КВОТЫ
=====

Вначале необходимо установить пакет quota:
apt-get install quota
монтируем диск со спец. параметрами (ключи usrquota - пользовательская квота, grpquota - групповая квота),
для этого прописываем параметры монтирования в fstab:
/dev/sdb1	/mnt/hard	auto	rw,user,auto,usrquota,grpquota	0	0
после этого делаем монтирование:
mount /dev/sdb1
чистим квоты, если таковые были:
quotaoff /mnt/hard

создадим квоты (ключ -cug создаст квоты для пользователей и групп):
quotacheck -cug /mnt/hard
файл. система ext4 поддерживает только квотирование дисков (мы не можем установить квоты на папки)
после этого в папке /mnt/hard появляются ф-лы aquota.group и aquota.user
Чтобы отредактировать эти ф-лы исп. команда edquota (ключ -u для юзера -g для группы пользователей):
edquota -u semaev
soft (Кбайт)- мягкая квота, юзер может превысить, но не > 1 недели, потом блокирует, hard (КБайт)- жесткая квота блокирует сразу;
blocks - сколько пользователь занимает 1-КБайтных блоков (сколько Килобайт)
inodes - сколько можно создать ф-лов и папок (тоже указ-ся soft и hard-квоты)
edquota - м. отредактировать значения квот
edquota -t
потом необходимо включить квотирование:
quotaon - чтобы включить квотирование
quotaon /mnt/hard
создадим пустой ф-л:
touch /mnt/hard/file.txt
посмотрим как изменились квоты
edquota -u semaev
стало blocks - 4, inodes - 2
редактируем ф-л, к-во блоков увеличилось до 8, потом когда значение превысит лимит hard-квоты не разрешит работать на этом разделе.
посмотреть отчет по квотам:
repquota /mnt/hard/
столбец grace показывает период блокировки
warnquota - посылает email пользователям превысившим квоту
----------------------------------------------------------

ПРАВА ДОСТУПА К ФАЙЛАМ И ПАПКАМ
===============================
chown	- установка владельца
chgrp	- установка группы владельцев
chmod	- установка прав доступа

сменить владельца ф-ла 1.txt на andrey:
chown andrey 1.txt
сменить группу владельцев ф-ла 1.txt на гр. testers:
chgrp testers 1.txt
или та же операция
chown :testers 1.txt
поменять одновременно владельца и группу владельцев:
chown andrey:testers 1.txt
рекурсивное изменение владельца папки с вложениями:
chown -R andrey Folder

первая буква хар-зует тип оюъекта (d-directory, l-link):
drwxr-xr-x 2 semaev testers 4096 нояб. 11 13:40 Folder
-
запретим всем запускать ф-л (ключи ugo 'user group other'):
chmod ugo-x 1.txt
существующему юзеру (владельцу) добавить права на выполнение:
chmod u+x 1.txt
поменять права на файл (юзеру-чтение,запись;группе-чтение;остальные-нет прав):
chmod 640 1.txt
дать всем полные права:
chmod 777 1.txt
разрешить всем (юзеру,группе,остальным) выполнение:
chmod +x 1.txt
чтобы попасть внутрь папки должно стоять execute (выполнение) 

umask			- маска создания файлов и папок
suid (sid user id)	- бит запуска от имени владельца
sgid			- бит запуска от имени группы владельцев
sticky			- бит защиты содержимого

Параметр маски безопасности с которой создаются файлы и папки по умалчанию м. посмотреть в ф-ле
/etc/login.defs:
grep UMASK /etc/login.defs
покажет 
UMASK	022

установка битов для запуска от имени обычного пользователя (опасно):
Позволяет всем пользователям запускать от имени владельца файла
chmod u+s 1.txt
ls покажет права (x заменяется на s)
-rwsrwx---
также статистика по ф-лу:
stat 1.txt
покажет:
Доступ: (4770/-rwsrwx---)

убрать бит:
chmod u-s 1.txt

добавить бит для группы пользователя:
chmod g+s 1.txt
статистика покажет
Доступ: (2770/-rwxrws---)
добавить и юзеру и группе stiky-бит:
chmod ug+s 1.txt
статистика покажет
Доступ: (6770/-rwsrws---)
можно убрать все sticky-биты:
chmod 0755 1.txt

мягкие и жесткие ссылки:
inod (номер inod) - идентификатор (местонахождение/метка) ф-ла (индексный дескриптор)
мягкие ссылки опираются на полное имя ф-ла (занимают определенное место на диске, м. создавать ссылки на папки)
в правах доступа указывается первая буква l
например
lrwxrwxrwx
жесткая ссылка указывает на тот же самый inod (изменение имени исходного ф-ла не затрагивает данную ссылку, не занимают места на диске
нельзя создать ссылку на другой ф-ловой системе, нельзя создавать ссылки на папки)
LN - создает ссылки
без аргументов создает жесткую ссылку на файл, мягкую с ключем -s
жесткая ссылка на файл file.txt:
ln file.txt hard.txt (м.б без расширения)
мягкая (символическая) ссылка на файл file.txt:
ln -s file.txt soft.txt
создать мягкую ссылку на файл file.txt в папке folder:
неправильная запись (создаст битую ссылку, т.к. б. искать ф-л в папке Folder):
ln -s file.txt Folder/
правильно писать полный путь до файла:
ln -s /home/semaev/file.txt Folder/
ls -l вторым столбцом покажет сколько есть ссыло на данный inod
например показывает что есть 2 ссылки (т.е. файл и 1 линк):
-rw-rw-r--	1	semaev	semaev	0 февр. 11 13:14	copy.txt
-rw-rw-r--	2	semaev	semaev	0 февр. 11 13:14	file.txt
-rw-rw-r--	2	semaev	semaev	0 февр. 11 13:14	hard.txt
ls -li (покажет 3-им столбцом)
inod	security	links	user	group	size	data/time		name
408502	-rw-rw-r--	1	semaev	semaev	0	февр. 11 13:14		copy.txt
408507	-rw-rw-r--	2	semaev	semaev	0	февр. 11 13:14		file.txt
408507	-rw-rw-r--	2	semaev	semaev	0	февр. 11 13:14		hard.txt

Структура FHS (File Hierarchy Structure)
/bin	- базовые бинарники команд;
/boot	- файлы загрузчика;
/dev	- устройства;
/etc	- конфигурация ПК;
/home	- домашние папки;
/lib	- библиотеки и модули ядра;
/proc	- информация о работающей системе;
/media	- монтирование носителей;
/mnt	- монтирование носителей;
/opt	- дополнительное ПО;
/root	- домашняя папка админа;
/sbin	- основные программы настройки системы;
/srv	- данные для системных служб;
/tmp	- временные ф-лы;
/usr	- бинарные файлы пользователей;
/var	- переменные

grep	- утилита поиска по содержимому;
find	- утилита поиска фалов по св-вам;
locate	- быстрый поиск файлов;
which	- поиск команды;
type	- вывод точной команды;
whereis	- поиск команды, исходников и мануала

поиск файлов в корне, всего, что имеет отношение к mail (точное совпадение, работает с символами/ключами):
find / -name mail

LOCATE - тоже самое, только быстрее (все, что содержит слово mail)
ищет только в определенных местах, работает только с индексной локацией
Раз в день запускает программу find и индексирует ф-лы создавая БД нахождения файлов
locate mail
покажет настройки поиска locate:
cat /etc/updatedb.conf
не ищет в ф-лах .git .bzr .hg .svn
не ищет в папках /tmp /var/spool /media /home/.ecryptfs
не ищет в файловых системах nfs,smbfs,iso9660...
вручную запустить обновление базы поиска locate:
updatedb

покажет где находится команда ls:
which ls
покажет
/bin/ls

покажет с какими ключами по умолчанию запускается команда ls:
type ls
покажет
ls является алиасом для 'ls --color=auto'

показывает подробную инф. по программе:
whereis ls
покажет где находится и в какой пакет входит:
ls: /bin/ls usr/share/man/man1/ls.1.gz
-------------------------------------------------------------

Управление SYSTEMD
==================
Unit - модули которыми оперирует systemd
.service - службы;
.mount - точки монтирования;
.device - устройства;
.socket - сокеты
.target - группировка последовательно запускаемых юнитов

Директория с юнитами по умолчанию:
/usr/lib/systemd
Директория с управляемыми юнитами:
/etc/systemd

Runlevel	target			описание
-------------------------------------------------

0		poweroff.target		Выключение
1		rescue.target		Однопользовательский режим
2,4		multi-user.target	Настраиваемый режим
3		multi-user.target	Многопользовательский режим
5		graphical.target	Графика
6		reboot.target		Перезагрузка


Управление системы (контроль системы) осущ. командой SYSTEMCTL
==============================================================
Просмотр запущеных юнитов (устройства, точки монтирования, службы, сокеты):
systemctl list-units
Просмотр юнитов, которые не запустились:
systemctl --failed
Просмотр юнитов, которые отвечают за запущенные службы:
systemctl list-units --type=service
Просмотр юнитов, которые отвечают за запущенные таргеты:
systemctl list-units --type=target

Просмотр статуса/запуск/стоп службы crond:
systemctl status crond
systemctl stop crond
systemctl start crond

Перейти в однопользовательский режим:
systemctl isolate rescue.target
или (как в sysv)
telinit 1

Сделать "Однопользовательский режим" таргетом по умолчанию:
systemctl set-default -f multi-user.target
где f-форсировать

Управление службой журналирования journald
==========================================
Просмотр событий по мере их возникновения:
journalctl -f

Вывод последних 10 событий:
journalctl -n 10

Вывод событий по UID пользователя:
journalctl _UID=0
-----------------------------------------

MY SQL
======
устанавливаем пакет сервера с клиентом:
apt-get install mysql-server
подключаемся к БД под юзером root (если у root задан пароль ставим ключ -p и вводим пароль ):
mysql -u root
появится ком. строка mysql
mysql>
создадим БД:
CREATE DATABASE cars;
подключаемя к БД:
USE cars;
создадим таблицу с полями:
CREATE TABLE new (brand VARCHAR(10), madel VARCHAR(10), year YEAR, coast INT);
показать таблицы БД:
SHOW TABLES;
показать структуру таблицы new:
DESCRIBE new;
выйти из mysql:
exit
создадим текст. ф-л со значениями БД с разделителем полей <tab>
для импорта текст. файла сначала необходимо включить эту возможность в mysql:
mysql --local-infile=1 -u root
для импорта входим в режим mysql и открываем таблицу cars:
USE cars;
загрузить данные из локального input-ф-ла:
LOAD DATA LOCAL INFILE "new.txt" INTO TABLE new;
посмотрим что импортировалось:
SELECT * FROM new;
сделать вставку данных в поля (brand, model, year) таблицы:
INSERT INTO new (brand, model, year) VALUES ('Daewoo','Nexia','2015');
удалить из таблицы информацию о Matiz:
DELETE FROM new WHERE model='Matiz';
подключаемся сразу к таблице БД:
mysql cars -u root
показать таблицы:
SHOW TABLES;
показать KIA 215 года:
SELECT * FROM new WHERE brand="KIA" AND year="2015";
изменить информацию в таблице:
UPDATE new SET model='KUGA' WHERE model='FOCUS';
вывести все из таб-цы new где поле brand= полю brand из таб. used:
SELECT * FROM new JOIN used ON new.brand = used.brand;
выбрать все из таб. new отсортировав по полю brand:
SELECT * FROM new ORDER BY brand;
группировать по полю brand:
SELECT * FROM new GROUP BY brand;
------------------------------------------------------------------

ФАЙЛОВЫЙ СЕРВЕР SAMBA
ПРОГРАМНЫЙ RAID
=====================

Смотрим какие диски установлены:
fdisk -l
Создадим разделы на диске /dev/sdb:
fdisk /dev/sdb
создадим новый раздел: n
выберем primary: p
соглашаемся создать раздел на весь диск
для выбора файловой системы нажимаем: t
создадим linux raid autodetect: fd
посмотрим результат: p
запись изменений: w
На втором диске создадим такой же раздел (/dev/sdc)
Для создания программного рейда используем программу mdadm
Установим ее:
apt-get install mdadm
Запустим ее с ключами (--create создать, --verbose показать, визуально,
диск рейда md0 --level=1 (1 уровень "зеркало"), --reid-devices=2,
указываем тома которые будут использоваться sdb1 sdc1 ):
mdadm --create --verbose /dev/md0 --level=1 --raid-devices=2 /dev/sdb1 /dev/sdc1
покажет:
mdadm: array /dev/md0 started
посмотреть процесс создания:
cat /proc/mdstat
чтобы смотреть процесс в реальном времени (обновление каждые 2 сек):
watch cat /proc/mdstat
посмотрим конф. файл mdadm:
cat /etc/mdadm/mdadm.conf
покажет из каких устр-в собирается массив (--detail детально,--scan просканировать,--verbose показать):
mdadm --detail --scan --verbose
Чтобы после перезапуска сказать системе, что нужно собирать диск из дисков...
в ф-л конфига нужно будет дописать:
echo "Device partitions" >> /etc/mdadm/mdadm.conf
допишем в файл предыдущую команду (используя команду awk):
mdadm --detail --scan --verbose / awk '/ARRAY/ {print}' >> /etc/mdadm/mdadm.conf
в конфиг также м. дописать адрес почты на которую будут отправляться сообщения о критич. состоянии рейда:
(если настроен почтовый сервер)
echo "MAILADDR mberdyugin@gmail.com" >> /etc/mdadm/mdadm.conf
после создания рейда диск md0 будет показан отдельным устройством в системе (fdisk -l)
после создания этого диска, на нем тоже нужно будет создать ф-ловую систему:
fdisk /dev/md0
n
p
t (тип ф-ловая система линукс "83")
покажет, что создался раздел (/dev/md0p1 "партиция 1"), запишем изменения: w
форматируем раздел:
mkfs.ext4 /dev/md0p1
чтобы диск с raid-массивом не менял свое имя "md0" после перезагрузки системы напишем:
обновить диск initram, который создается при старте системы в оперативной памяти
update-initramfs -u

проверим впорядке-ли raid-массив:
cat proc/mdstat
покажет:
md0: active (auto-read-only) raid1 sdc[1] sdb[0]
смонтируем диск с raid в папку /data:
mount /dev/md0p1 /data
посмотрим разрешения на диск смонтированный в папку:
stat /data
сделаем группу semaev группой владельцев ф-ла:
chown root:semaev data
поставим полные права для владельца и группы владельца ф-ла:
chmod 775 data
чтобы после перезагрузки системы автомат. монтировался в эту папку:
узнаем id раздела raid:
blkid
установим пакет для работы с мышью:
apt-get install gpm
(скопировать - enter, втавить - нажать scroll мыши)
допишем в файл /etc/fstab:
UUID=35gf3ec8-e5ff-4828-hgh...	data	ext4	defaults	0	0

при сбое одного из дисков raid-массива м. выйти сообщение закрытое квадратиками.
Говорится, что устр-во смонтированное в папку /data не может б. смонтировано из-за отсутствия одного из дисков
Предоставляется выбор нажать S (skipe- пропустить и продолжить работать дальше не собирая этот диск) или М
(перейти в режим manual recovery).
В режиме manual - запускается run level 1 (не работают никакие ПО и сервисы)
Нажимаем S и смотрим:
cat /proc/mdstat
покажет:
md0: inactive sdb1[0] (S)
sdb0 - inactive (не работает), есть только диск sdb1
чтобы запустить raide-массив для начала нужно его остановить:
mdadm --stop /dev/md0
теперь raid-массив нужно пересобрать:
mdadm --assemble --scan
стартует его с одним диском из 2-х
теперь смонтируем этот диск пока вручную:
mount /dev/md0p1 /data
посмотрим raid:
cat /proc/mdstat
покажет:
md0: active raid1 sdb1[0]
посмотреть детальную информацию по raid-диску:
mdadm --detail /dev/md0
покажет, что один диск degraded
подключим новый диск
посмотрим какие есть диски:
fdisk -l
(можно на него скопировать mbr или gpt, но мы поступим по старому):
в системе он обозначен под именем /dev/sdc
подготовим диск для raid-массива:
fdisk /dev/sdc
n
p
t
fd
укажем этот диск, как 2-й диск для raid-массива (--add добавить том диска /dev/sdc1):
mdadm /dev/md0 --add /dev/sdc1
запустит процесс синхронизации
покажет что передобавил том /dev/sdc1:
mdadm: re-added /dev/sdc1
проверяем:
cat /proc/mdstat
покажет:
md0: active raid1 sdc[2] sdb1[0]
-------------------------------------------------------------------------------------
SAMBA
http://smb-conf.ru/

создадим папку /data/shared
mkdir /data/shared
посмотрим разрешения:
stat shared/
установим пакет samba:
apt-get install samba
настройки файл. сервера в конфигурационном файле:
/etc/samba/smb.conf
скопируем оригинал на всяк случ.:
cp smb.conf smb_orig.conf
в нем:
где хранятся пароли (встроенная БД tdsam):
passdb backend = tdbsam
программа исп. для проверки паролей:
passwd program = /usr/passwd
диалог паролей:
passwd chat = *Enter\snew\s*\spassword:*....
PAM -подключаемый модуль аутентификации
Допишем в файл отдельную секцию для работы с нешей папкой:
[Shared folder]
как будет называться папка по сети:
comment = NewName
путь к папке:
path = /data/shared
наследование icls (access control list):
наследование безопасности (маска безоп. вышестоящей папки)
inherit acls = yes
чтобы наследовался владелец папки:
inherit owner = yes
наследовать разрешения:
inherit permissions = yes
сделать доступной для записи в нее:
writable = yes
если только для чтения - значение no
пользователи которые имеют право работать (могут подключаться):
valid users = semaev
пользователи которые имеют доступ "только на чтение":
read list = semaev
пользователи у которых есть доступ только на запись:
write list = semaev
принудительно, чтобы пользователь был buh1:
force user = buh1
принудительно, чтобы группой пользователей была Buhs:
force group = Buhs
заменить маску создания файлов и папок:
create mask = 0777
можно не вводить логин и пароль:
guest ok = yes
в конце ф-ла оставляем пустую строку (иначе последние значения не увидит)

запустим утилиту проверки конфигурации samba (сама или подсказывает или меняет):
testparm
надо добавить локального пользователя semaev в базу данных пользователей samba:
ключ -а добавить
smbpasswd -a semaev
спросит пароль для входа пользователя в samba
после вноса изменений в samba неободимо ее перезапускать (демон smbd):
service smbd restart

создадим группу пользователей Buhs в samba:
groupadd Buhs
создадим пользователей в этой группе (ключ -G):
useradd -G Buhs buh1
зададим для юзера buh1 пароль:
passwd buh1
создадим папку /data/shared2 и поменяем владельца и разрешения на buh1:
mkdir shared2
chown buh1:semaev shared2
chmod 770 shared2 
открываем конфиг samba и создаем для каждой общедоступной папки свою секцию с настройками доступа

aptitude - установщик
обновляет информацию о своих репозиториях (линки серверов) установщика пакетов aptitude:
aptitude update
посмотреть информацию о пакете winbind (используется для привязки к домену):
aptitude search winbind
статус р - показывает, что пакет не установлен
также для работы samba с доменом нужны пакеты:
winbind - осуществляет привязку к домену
krb5-user - клиент протокола kerberos
ntp (network time protokol) - используется для синхронизации времени в домене
aptitude install winbind krb5-user ntp
при установке kerberos5 попросит ввести имя домена (kemont.kz), имена контроллеров домена через пробел (srvdc01.kemont.kz)
и кто является первичным контроллером
еще необходимо доустановить еще след. пакеты (хотя возможно они уже установились):
libpam-krb5 - библиотека модуля pam (plugin authentication module) для kerberos5
libpam-winbind - библиотека модуля pam для winbind
libnss-winbind - библиотека nss для winbind
aptitude install libpam-krb5 libpam-winbind libnss-winbind

в ubuntu параметры dns лежат в ф-ле:  /etc/resolv.conf
если у нас статическая адресация, то нужно править ф-л: /etc/resolvconf/resolv.conf.d/head
все что напишем сюда, будет автоматически добавляться в ф-л /etc/resolv.conf
для того, чтобы по dhcp получить корректную адресацию можно отредактировать ф-л: /etc/dhcp/dhclient.conf
в нем нужно откомментировать 2 строки:
1. перезаписать имя домена (supersede domain-name "kemont.kz";)
2. переуказать имя dns-сервера (prepend domain-name-servers 192.168.114.15;)
тогда он будет игнорировать настройки dhcp-сервера и брать, что мы укажем.
Чтобы переименовать имя компа, правим ф-л: /etc/hostname
при статич. адресации явно указываем соответствие имен (c dns-суфиксом) адресам в ф-ле: /etc/hosts
192.168.114.15	srvdc01.kemont.kz
проверим правильность получения информации о хостах командой nslookup
nslookup srvdc01
настроим демон времени:
/etc/ntp.conf
указываем сервером времени вместо списка серверов server ntp.ubuntu.com.... имя нашего контроллера домена:
server srvdc01.kemont.kz
чтобы применились изменения рестартуем демон ntp:
/etc/init.d/ntp restart
проверяем настройки kerberos:
/etc/krb5.conf
д.б. правельно заполнены строчки:
default_realm = KEMONT.KZ
kdc = srvdc01.kemont.kz
admin_server = srvdc01.kemont.kz
в секции [domain_realm] дописываем:
.kemont.kz = KEMONT.KZ
kemont.kz = KEMONT.KZ
проверяем вход в домен (под администратором домена adadmin) для этого мы должны запросить билет kerberos у контроллера домена (kinit - kerberos initialisation):
kinit adadmin@kemont.kz
после ввода пароля пускает
чтобы это проверить вводим команду klist (kerberos list) - покажет информацию о полученном билете kerberos

отредактируем файл конфигурации samba /etc/samba/smb.conf
в рабочей группе указываем короткое имя (без суфикса):
workgroup = KEMONT
после него дописываем параметр:
realm = KEMONT.KZ
после строки server string след. строки (кто у нас будет отвечать за безопасность active directory service):
security = ADS
методы аутентификации (winbind (windows binding)- набор/пакет ПО отвеч. за привязку к Windows, ищет инф. о пользователях и паролях во всех местах):
auth methods = winbind
чтобы winbind умел пробрасывать пользователей домена на нашу локальную машину:
winbind enum users = yes
тоже самое по группам:
winbind enum groups = yes
winbind использовать домен по-умолчанию (чтобы исп. в написании пользователя короткое имя, а не semaev@kemont.kz):
winbind use default domain = yes
разделитель в написании объектов домена (например \ - kemont\mberdyugin):
winbind separator = /
чтобы правильно выдавались id доменным учеткам (м.было шарить для доменных учеток) следует добавить диапазоны id:
idmap config * : range = 10000-20000
можно закоментировать строку (роль сервера - автономный сервер):
#server role = standalone server
БД паролей:
#passdb backend = tdbsam
настройки pam:
#obey pam restrictions = yes
синхронизация паролей UNIX:
#unix password sync = yes
программы для паролей:
#passwd program = /usr/bin/passwd %u
#passwd chat = ...
#pam password change = yes
#map to guest = bad user
запретим гостей:
#usershare allow guests = yes
секцию print$,printers
после выхода проверяем конфиг через testparm
утилита сама увеличивает лимит подключений к самбе, роль сервера на "член домена", соглашаемся нажимаем ENTER
на десктоповых версиях linux нужно проверить, что службы samba и winbind находятся в режиме автозапуска:
service winbind status
теперь добавим сервер samba в домен (с правами доменного юзера adadmin):
net ads join -U adadmin@kemont.kz
нужно указать ns (name service) switch, что всю информацию нужно брать в winbind:
для этого правим /etc/nsswitch.conf
там указано где ищется информация о пользователях, группах и т.д.
меняем строки:
passwd:	compat
group: compat
shadow: compat
на
passwd: files winbind
group: files winbind
shadow: files winbind
закрываем
перезагружаем сервер:
shutdown -r now
проверяем что linux понимает юзеров (-u) и группы (-g) windows:
wbinfo -u
wbinfo -g
должен их показать
команда id д.показать id пользователя
локального:
id semaev
доменного (должны пробрасываться в linux им д.присваиваться id в локальной системе):
id adadmin
проверим все ли пользователи получили id-шники (смотрит на конф. /etc/nsswitch.conf):
getent passwd
тоже для групп:
getent group
сменим владельца на доменную учетку для папки Shared (с ключем -v (verbose) визуально покажет рез-т команды):
chown -v adadmin:semaev Shared/
можно с группой владельцев "Пользователи домена":
chown adadmin:"Пользователи домена" Shared/
при работе в домене в конф. ф-ле samba не нужно для шар прописывать эти параметры (станет разрешено всем всё), тогда
доступ к ресурсам будет организовываться на уровне ф-ловой системы:
valid users,read list,write list,force user,force group
--------------------------------------------------------------------------------------------------------------------

ГРАФИЧЕСКАЯ СИСТЕМА X11
=======================

ищем пакет содержащий xorg:
apt-get update
apt-cache search xorg
для удобства чтения вначале сохраняем вывод в ф-л xorg.txt, затем его постранично посмотрим (стрелками вверх вниз):
apt-cache search xorg > xorg.txt
less xorg.txt
нашли
xorg - X.Org X Window System 
запускаем установку xorg:
apt-get install xorg
сконфигурировать установленный оконный сервер:
X -configure
конф. ф-л будет находиться:
/home/semaev/xorg.conf.new
все логи находятся:
/var/log/xorg.0.log
(WW) - строки сообщений warning
(II) - строки информационных сообщений
(EE) - строки сообщений error
запустим графическую подсистему (в ubuntu):
startx
после этого можно запустить любое приложение которое использует для вывода граф. подсистему (например firefox)
но лучше сразу установить граф. среду (gnome и т.д.), она корректно будет работать с оконной подсистемой.
команда xwinfo показывает информацию об активном окне:
xwinfo
и выбираем окно приложения
В ubuntu desktop при нажатии ctrl+alt+F1 из адаптированной консоли переключается в системную консоль терминала tty (teletype)
ctrl+c закроет текущий терминал
ctrl+alt+F2 откроет еще 2-ю консоль tty2 и т.д.
ctrl+alt+F7 вернемся в наш терминал с граф. оболочкой (display 0)
покажет какой сейчас активный дисплей:
echo $DISPLAY
покажет:
:0
запустим еще одну оконную подсистему:
startx
горячая клавиша вызова терминала: ctrl+alt+t
если в нем напишу echo $DISPLAY
покажет:
:1.0 (теперь используется 1-й монитор)
можно указать на каком дисплее я хочу запустить графику:
startx -- :5
команда xhost разрешает удаленным приложениям использовать мой монитор (добавит этот хост в acl для x11):
xhost +192.168.0.55
на удаленной машине, чтобы захватить мой монитор нужно написать (ip моей машины:мой активный монитор):
для этого x-сервер (моя машина) д.б. спец.настроен
DISPLAY=192.168.0.10:0.0
---------------------------------------------------------------------------------------------------------

МЕНЕДЖЕРЫ ДИСПЛЕЯ GDM,KDM,XDM
=============================

для ubuntu:
установим дисплей-менеджеры (только окно входа в систему):
apt-get install gdm kdm xdm
настройки дисплей менеджера:
/etc/X11/default-display-manager
покажет какой менеджер используется, например "/usr/sbin/gdm"
можно поменять используемый dm командой или изменить конфигурационный ф-л:
dpkg-reconfigure kdm
появится окнос выбором дисплей-менеджера
в конф.ф-л запишется какой менеджер используется "/usr/sbin/kdm"
после выполнения reboot, окно входа поменяется
чтобы отключить gdm, зайдем в его конф.ф-л:
/etc/init/gdm.conf
правим значения runlevel, на которых он может стартовать и останавливаться (ставим не запускать на логоне runlevel 2)
чтобы отключить xdm нужно выполнить (-f force):
update-rc.d -f xdm remove
настройки gdm хранятся:
/etc/dconf/db/gdm.d/
--------------------
добавим приветствие, для этого в папке нужно создать ф-л:
/etc/dconf/db/gdm.d/01-banner-message
(для ubuntu)
заполним его:
[org/gnome/login-screen]
banner-message-enable=true
banner-message-text='Greetings, earthlings!'
после создания ф-ла обновляем БД менеджера дисплея gnome:
dconf update
перегрузим систему: reboot
в этом ф-ле так-же редактируется фон рабочего стола, выпадающий список, расположение иконок и т.д.

чтобы тоже самое проделать с менеджером дисплея xdm
поменяемменеджер на xdm
dpkg-reconfigure xdm
переходим в папку:
/etc/x11/xdm
откроем ф-л /etc/x11/xdm/Xresources
ищем параметр xlogin*greeting и вводим любое значение
xlogin*greeting: Welcome, dear friends!
делаем reboot
также здесь можно определить ниспадающий список пользователей, можно спрятать пользователей списка и т.д.

чтобы тоже самое проделать с менеджером дисплея kdm
поменяемменеджер на kdm
dpkg-reconfigure kdm
переходим в папку:
/etc/kde4/kdm
открываем инициализационный скрипт
vi /etc/kde4/kdm/kdmrc 
ищем слово welcome:
/welcome
находим строку:
Default is "Welcome to Kubuntu at %n"
можно раскоментировать переменные указанные выше после строчки:
The headline in the greeter. The following character pairs are replaced:
%h - выводит имя машины
но все это не будет работать, т.к. идет привязка к теме раб. стола
можно поменять настройки темы (установлена oxygen), строка:
Theme=/usr/share/kde4/apps/kdm/themes/oxygen
идем в папку с темами:
cd /usr/share/kde4/apps/kdm/themes/
открываем ф-л oxygen
vi /usr/share/kde4/apps/kdm/themes/oxygen
видим ссылку наф-л oxygen.xml
открываем его
oxygen.xml
в нем ищем строчку:
<stock type="welcome-label"/>
она говорит о типе приветствия
меняем на свою фразу и перегружаем систему

lightdm - облегченный дисплей-менеджер
по умолчанию на ubuntu desktop уже установлен
для его установки на ubuntu server пишем:
apt-get install lightdm
потом нужно будет ставить еще доп. пакеты
заходим в его конф. файл
/etc/lightdm/lightdm.conf
здесь можно поставить автологин для юзера:
autologin-user=semaev
мануал по работе с lightdm находится в /usr/share/doc/lightdm/lightdm.conf.gz
распакуем его:
gunzip lightdm.conf.gz
смотрим:
less lightdm.conf
по умолчанию этот дисплей-менеджер управляется темой /usr/share/xgreeters/unity-greeter.desktop
установим тему lightdm-gtk-greeter:
apt-get install lightdm-gtk-greeter
после чего она появится в папке /usr/share/xgreeters/
добавим строчку с этой темой в конф. файл:
greeter-session=lightdm-gtk-greeter
перегружаем и видим новую тему входа в систему

дисплей менеджер для CENTOS (red hat systems)
установим несколько пакетов д.м.GNOME с пом. yum
yum groupinstall "GNOME Desktop" "Graphical Administration Tools"
в CENTOS возможно только использование дисплей-менеджера GNOME
можно его также выбрать при установке
-----------------------------------------------------------------------------------------------

УПРАВЛЕНИЕ ПОЛЬЗОВАТЕЛЯМИ И ПАРОЛЯМИ
====================================

файл БД в котором хранятся сведения пользователей, есть доступ для всех пол-лей:
/etc/passwd
содержит например:
имя пол-ля:х-говорит, что пароль хран-ся в теневой папке:id user:id group:прочая информация о группе:домашняя папка пол-ля:оболочка, которая используется при входе (в д.сл. пол-ль games не может войти в систему используя стандартный экран входа(дисплей-менеджер))
games:x:5:60:games:/usr/games:/usr/sbin/nologin
например у обыч пол-ля последнее значение: /bin/bash - используется для входа в систему
файл БД в котором хранятся сведения о группах, есть доступ для всех пол-лей:
содержит например:
группа пол-лей:пароль хранится в теневой папке:id group:члены группы cdrom:
cdrom:x:24:semaev
ф-л в котором хранятся теневые пароли, доступ только для пол-ля root:
/etc/shadow
содержит например:
имя пользователя:*-пароль закрыт, т.е. отсутствует (нельзя залогинится стандартным диалогом входа) !-говорит о том, что пароль существует и заблокирован, но мы можем стандарт. командами его разблокировать
games:*:16547:0:99999:7:::
или
имя пол-ля:зашифр. пароль:срок к-рый прошел с последнего изменения пароля в днях (по умол. с 1970г.):0-минимальный срок действия пароля (г.о том что можно сменить пароль сразу:99999-максимальный срок действия пароля в днях:7- кол-во дней до истечения предыдущего срока 99999 у нас начнет появляться предупреждение)
semaev:$hfjhjhjsh..:16500:0:99999:7:::
ф-л теневых паролей групп, доступ только для пол-ля root:
/etc/gshadow
в этих ф-лах ничего не меняем, для изменения значений используются команды кот. рассмотрим далее

useradd - создание пользователей;
passwd - установка пароля для пол-лей;
usermod - изменять св-ва польз-лей;
userdel - удалять пол-лей;
интересные ключи:
-d указание домашней папки по умолчанию;
-g id группы к которой мы хотим добавить этого пользователя (по умолч. создается одноименная группа пол-ля);
-G перечислить группы по названиям если мы хотим добавить пол-ля в к-то спецфическую группу;
--create-home создастся домашняя папка сразу, до входа в систему;
-p или --password можно сразу указать пароль п-ля;
-s указать оболочку пол-ля, кот-я б. использоваться по умолчанию;
-u м. указать id пол-ля который хотим чтобы был (по умолчанию присваивается по-порядку от 1000);
создадим пол-ля buh (ключ -m создать папку сразу, -G включить в группу sambashare):
useradd -m -G sambashare buh
сразу проверяем, как завелся пол-ль в ф-лах БД паролей
установим пароль для польз-ля buh:
passwd buh
просто набрав команду м. сменить пароль текущего пол-ля:
passwd
заблокировать учет. запись пол-ля buh (ключ -L):
usermod -L buh
посмотрим как отразилось на записи теневого пароля в ф-ле:
/etc/shadow
где перед хэшем паролья будет стоять знак !
разблокируем пол-ля buh (ключ -u):
usermod -U buh
смотрим ф-л /etc/shadow, знак ! перед паролем убран
поменяем пол-лю buh оболочку для работы по умолчанию (ключ -s) и поставим комментарий (ключ -c):
usermod -s /bin/bash -c "My favorite" buh
проверяем, открываем БД п-лей:
/etc/passwd
удалим пол-ля buh и удалим его домашнюю папку (ключ -r):
userdel -r buh
------------------------------------------------------------------------------------------------

groupadd - добавить группу пол-лей;
groupmod - изменить группу;
groupdel - удалить группу;
chage - меняет настройки учет. записи;
getent (get entries - получить записи) - ищет сведения в БД уч. записей, умеет работать с службами AD,LDAP;

groupadd
ключи:
- g устанавливаем id группы вручную;
- p или --password установить пароль на группу (используется для смены группы владельца)
добавим группу groupadd:
groupadd clowns
проверяем ее создание в БД:
/etc/group
изменим для пол-ля buh группу пол-лей clowns (ключ -ag перезаписывает группу пол-лей по id группы, -G по имени группы):
usermod -aG clowns buh
проверяем ее изменение в БД групп /etc/group
изменим id группы clowns на 25000:
groupmod -g 25000 clowns
удалим группу clowns:
groupdel clowns
посмотреть св-ва пользователя (ключ -l):
chage -l semaev
изменить срок истечения учетной записи 9 янв. 2016 (ключ -E в формате YYYY-MM-DD)
chage -E 2016-01-09 semaev
сбросить все настройки к исходным (ключ -1):
chage -E -1 semaev
посмотрим теневые пароли:
getent passwd
посмотрим теневые пароли п-ля semaev:
getent passwd semaev
посмотреть ф-л кот. отвечает за группы:
getent group
---------------------------------------------------------------------------------

АВТОМАТИЗАЦИЯ ЗАДАЧ (ПОВТОРЯЮЩИХСЯ), ПЛАНИРОВЩИК CRON
=====================================

как работать с системными задачами планировщика:
конфигурация планировщика cron находится в ф-ле /etc/crontab
там записываются задания планировщика
crontab должен заканчиваться переводом строки
есть еще планировщик anacron, его конфиг лежит в ф-ле:
/etc/cron.d/anacron
в эту папку (cron directory) устанавливаются скрипты для всех устанавливаемых программ, если у них есть к-то запланированные действия 
посмотрим какие есть ф-лы с фразой cron в папке /etc:
ls /etc -l | grep cron
покажет папки, где лежат скрипты выполняемые по соотв. расписанию:
cron.d,cron.daily,cron.hourly,cron.mounthly,cron.weekly и ф-лы anacrontab,crontab
можем закинуть в эти папки уже готовые скрипты, и в зависимости в какую папку мы их положим, они б. выполняться или ежедневно, ежечасно, еженедельно, ежемесячно
если в crontab есть строка 01 * * * * root run-parts /etc/cron.hourly, то скрипты лежащие в директории cron.hourly б. запускаться в 01 минуту каждого часа?
----------------------------------------------------------------------------------------------------------------------------------------------------------------

как работать с пользовательскими задачами планировщика, управлять доступом к планировщику:
посмотреть (ключ -l)какие есть задачи у текущего польз-ля:
crontab -l
чтобы создать задачу (ключ -e edit)
crontab -e
предложит выбрать редактор с пом. которого создать задание
добавим строку в 8часов по будням будет запускаться сканер drweb с ключами проверки системы:
00 08 * * 1-5 /usr/bindrweb/scanner -scan -all
смотрим какие появились задания, смотрим папку ls /var/spool/cron
покажет папку crontabs, в ней создаются ф-лы по имени польз-ля (в ubuntu)
--------------------------------------------------------------------------------------------

приоритет разрешения allow доступа к cron выше чем запрета deny
создадим ф-л с запретом доступа /etc/cron.deny, он в себе д. содержать имена п-лей к-рым запрещен доступ к планировщику, добавим в него строку semaev
проверим под пол-ем semaev попробуем создать задание в crontab:
crontab -e
напишет:
You (semaev) are not allowed to use this program (crontab)
теперь создадим ф-л /etc/cron.allow и запишем туда semaev
теперь получиться запустить планировщик
если мы удалим ф-л cron.deny (лист запретов) и удалим строку semaev из ф-ла cron.allow, то мы опять не сможем запустить планировщик, т.к. есть созданный ф-л (лист с разрешениями), но в нем нет разрешения для пол-ля semaev
если еще удалим лист разрешений rm /etc/cron.allow, то опять будет разрешать запускать планировщик всем пол-ям.
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

АСИХРОННЫЙ ПЛАНИРОВЩИК (ПОВТОРЯЮЩИХСЯ) ЗАДАЧ ANACRON И ПЛАНИРОВЩИК ЗАДАЧ AT
===========================================================================

anacron - не поддерживает запуск задач по расписанию, но может запускать задания в интервале времени (исп. как дополнение к cron)
минимальный интервал выполнения - день
допустим частота выполнения задания в днях
файл конфигурации anacron:
/etc/anacrontab
содержит одну из строк:
день	задержка(мин)	метка (id)		задание
1	5		cron.daily		run-parts --report /etc/cron.daily
7	10		cron.weekly		run-parts --report /etc/cron.weekly
@monthly	15	cron.monthly		run-parts --report /etc/cron.monthly
(каждый день проверяет выполнялись ли задачи cron.daily и если не выполнялись, то выполняет задание каждый день с задержкой в 5 минут)
(раз в 7 дней проверяет выполнялись ли задачи cron.weekly и если не выполнялись, то выполняет задание каждый день с задержкой в 10 минут)
(раз в месяц нужно запускать задачу cron.monthly с задержкой в 15 минут)
выполнив задачу anacron записывает дату выполнения задачи в соотв. ф-лы наход. в папке /var/spool/anacron:
cron.daily,cron.weekly,cron.monthly
в папке /etc/cron.daily находится скрипт 0anacron, что говорит о том что первым будет запускаться скрипт anacron
в ubuntu и в др. debian-системах стандартный планировщик cron проверяет если в системе помимо cron установлен anacron, то он отдает управление ему, что позволяет избежать 2-хкратного запуска задач
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

установим планировщик at:
apt-get install at
покажет что у нас запланировано:
atq
создадим пустой ф-л script
touch script
сделаем его исполняемым
chmod +x script
скажем at исполнять этот скрипт в 17-00:
at 17:00
переходим в режим написания скрипта
и пишем выполнить наш скрипт:
/home/semaev/script
выход из режимма написания ctrl+d
проверяем наличие задачи:
atq
покажет:
job1	Sun Jul 12 17:00:00 2015 a semaev
есть 1 задача выполнить ее в 17:00
можно создать задачу в формате сейчас + 15 минут:
at now + 15 minute
опять запустит режим написания задания
м. сказать запустить задачу 9 янв. 2015г. в 15:00:
at 15:00 01/09/2015
удалим 1-е задание:
atrm 1
также можно создавать списки доступа и запрета:
/etc/at.deny, etc/at.allow
--------------------------------------------------

SSH
===

публичный ключ сервера хранится в скрытой папке в профиле:
~/.ssh
cat known_hosts
можно записать ключ находящийся в данном ф-ле для всех пользователей системы,
для этого создадим ф-л:
vi /etc/ssh/ssh_known_hosts

RSA (фамилии Rivest,Shamir,Adleman)
криптографический алгоритм с открытым ключом - для подписи и шифрования;
DSA (Digital Signature Algorithm)
криптографический алгоритм с открытым ключом - только для подписи;

если на сервере другой пользователь, чем на локале, то подключение к серверу через ssh выглядит:
ssh admin@10.0.1.6
если такой же то:
ssh 10.0.1.6
создадим (сгенерируем) цифровой ключ с типом RSA на своей машине:
ssh-keygen -t rsa
создастся пара открытого и закрытого ключа в папке:
/home/semaev/.ssh/id_rsa
предложит ввести парольную фразу (некое предложение из слов)
после чего в папке появятся 2 ф-ла:
id_rsa, id_rsa.pub
теперь в кач-ве примера создадим пару ключей dsa:
ssh-keygen -t dsa
в папке появятся 2 ф-ла:
id_dsa, id_dsa.pub
скопируем сгенерированные публичные ключи через ssh на сервер (он б.знать что Я это я)
(-i ключ)
ssh copy-id -i .ssh/id_rsa.pub admin@10.0.1.6
сверим скопированный сертификат
смотрим у себя на ммашине:
cat .ssh/id_rsa.pub
смотрим кго насервере:
ssh admin@10.0.1.6
попросит один раз ввести парольную фразу на время сеанса (если подключение через графическую среду)
подключившись к серверу смотрим ф-л:
cat .ssh/authorized_keys
сверяем его
тоже самое можно проделать с ключом dsa
если подключение будет не через графику, для запоминания парольной фразы используем
запуск bash от имени (родителя) ssh-agent:
ssh-agent bash
ssh-add .ssh/id_rsa
просит ввести парольную фразу
тоже запомнит на время работы сеанса консоли
также если хотим сгенерить ключи для всех пользователей системы (на уровне хоста) (ключ -f где создать)
ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key
создадутся открытый и закрытый ключи в папке:
/etc/ssh
ключи ssh_host_rsa_key, ssh_host_rsa_key.pub
можно проверить данные ключи на сервере подключившись через ssh:
ssh admin@10.0.1.6
ls /etc/ssh
---------------------------------------------------------------------

ssh туннели
проброс портов и сессий х11
рассмотрим запуск графических окон с удаленной машины у себя на компе:
подключимся к серверу через ssh с ключом -X:
ssh -X admin@10.0.1.16
после подключения запустим к-либо ПО, например nautilus удаленного сервера
nautilus
закрыть сессию ctrl+c
м. запустить firefox удаленного сервера
скопируем через ssh файл 1.txt на машину 10.0.1.16 в папку /home/semaev
scp 1.txt semaev@10.0.1.16:/home/semaev
пробросим 80 порт через сервер ssh-сервер (10.0.1.16) с ключем -N (none ничего не делать)
с ключем -L (локальный порт 12345) на какой пробрасывать 80-й порт,
адрес веб-сервера (ya.ru 213.180.204.3) до которого пробросить порт 
ssh 10.0.1.16 -N -L 12345:213.180.204.3:80
если нужно пробросить неск. портов, то указываем их через пробел.
после этого открываем браузер и в адресной строке набираем
localhost:12345
открывается сайт ya.ru
закрываем сессию ssh: ctrl+c

ШИФРОВАНИЕ Ф-ЛОВ С ПОМОЩЬЮ GPG
==============================

сгенерируем ключ
gpg --gen-key
предлагает выбрать ключи для подписи и для шифрования
выбираем ключ по умолчанию (1) RSA и для подписи и для шифрования
для идентификации ключа нужен User ID
программа создаст его из вашего имени, комментария и адреса почты
вводим данные
для защиты секретного ключа вводим секрет. фразу
потом нам нужно минут 5 чем-то заниматься на компе, т.к. для создания ключа нужно 247 случайных байт
ключ создастся в скрытой папке ~/.gnupg
публичный ключ pubring.gpg
частный ключ secreting.gpg
посмотрим существующие ключи:
gpg --list-key
покажет:
pub	2048R/71168532 2016-05-31
uid		Kirill Semaev (semaevkey) <it.prepod@gmail.com>
sub	2048R/3C39B2A4 2016-05-31
где
uid - id кто регистрировал  ключ
pub - публичный (открытый) ключ используется для подписи
sub - подключ используется для шифрования
экспортируем sub-ключ и обозначим его допустим по комментарию semaevkey в ф-л gpg.public:
gpg --export semaevkey > gpg.public
отправим его тому кто хочет нам отправлять зашифрованную информацию с помощью этого ключа
допустим отправим его на удаленный ssh-сервер 10.0.1.6, там создадим файл, зашифруем его и перешлем обратно.
перешлем gpg.public:
scp gpg.public admin@10.0.1.6:/home/admin
для подключения к серверу попросит ввести секретную фразу
теперь подключимся к серверу через ssh:
ssh admin@10.0.1.6
~/ls
смотрим в папке ~/ появился ф-л gpg.public
смотрим есть ли к-либо ключи на удаленном сервере:
gpg --list-key
первый раз выполняя программа создает свою среду для работы
выполняем ее 2-й раз , показывает что никаких ключей нет
нам нужно его импортировать на удаленной машине
gpg --import gpg.public
теперь gpg --list-key покажет импортированный ключ
теперь создадим ф-л 1.txt и зашифруем его с помощью этого ключа
gpg --out secret.file --recipient 'Kirill Semaev' --encrypt 1.txt 
где secret.file (зашифрованный файл на выходе), recipient (получатель, указываем к-либо реквизиты ключа), encrypt (зашифровать какой файл)  
выходим с удаленного сервера
exit
скачаем зашифрованный ф-л к себе на машину:
scp admin@10.0.1.6:/home/admin/secret.file /home/semaev
расшифруем ф-л в ф-л с названием some.file:
gpg --out  some.file --decrypt secret.file
спрашивает ключевую фразу при создании ключа
------------------------------------------------------------------------------------------------------------------------------------------

ЛОКАЛИЗАЦИЯ И КОДИРОВКА
=======================
https://wiki.archlinux.org/index.php/Locale_(Русский)
переменная $LANG - основная настройка языка;
переменная LC_ALL - позволяет разом перезаписать все языковые настройки
команда LOCALE - показывает текущие языковые настройки
LANG=C - установка кодировки по умолчанию (исп-ся в начале скриптов)
посмотрим переменные среды командой env:
покажет языковые переменные
для языковых настроек программ использующих графическую оболочку:
LANGUAGE=en_US
для всего, что не установлено переменными LC_...(в locale):
LANG=en_US.UTF-8
команда locale покажет все языковые настройки
допустим если захотим поменять переменную LC_TIME:
задаем переменную:
LC_TIME=en_US.UTF-8
загружаем переменную:
export LC_TIME
проверяем вводим команду locale
если хотим все перезаписать и сделать русским:
LC_ALL=ru_RU.utf8
export LC_ALL
проверяем
locale
чтобы вернуть все в прежние значения (отменить настройку команды LC_ALL):
unset LC_ALL
посмотреть все доступные кодировки:
iconv --list
можем поменять кодировку напр-р в ф-ле /etc/fstab (по ум. в нем UTF-8) на ASCII и вывестина экран (ключ -o имя_файла_вывода):
iconv -f UTF-8 -t ASCII /etc/fstab
-----------------------------------------------------------------------------------------------------------------------------

УПРАВЛЕНИЕ ВРЕМЕНЕМ
===================

показывает текущую дату (системное время):
date
установим дату (в формате ЧЧММччммГГГГ)
date 010918001985
запустим мастер установки временной зоны:
tzselect
после чего
можно назначить вручную и выгрузить в перем. среды, например:
TZ='Europe/Moscow'
export TZ 
посмотреть таймзону в данный момент м. в ф-ле /etc/timezone
cat /etc/timezone
Значение 'Europe/Moscow' показывает папку с которой б. работать система:
/usr/share/zoneinfo/Europe/Moscow (бинарный ф-л Moscow)
на текущую врем.зону также указывает линк /etc/localtime (бинарник, в нем хранится информация текущей врем. зоны, св-ва: lrwxrwxrwx говорят что это линк)
Можем создать линк на временную зону Киева (создадим символическую ссылку):
ln -sf /usr/share/zoneinfo/Europe/Kiev /etc/localtime
проверяем какая временная зона стала текущей:
zdump /etc/localtime
В /usr/share/zoneinfo/ лежат бинарники часовых поясов формируемые спец. утилитой (сервисом), кот. считывает настройки временных зон
и создает эти ф-лы. Их можно просмотреть спец. утилитой zdump
допустим:
zdump Poland
в ubuntu, если мы посмотрим на св-ва ф-ла localtime (ls -l /etc), он не является символической ссылкой
в ubuntu ссылка localtime находится в /usr/share/zoneinfo
localtime -> /etc/localtime
Поэтому в ubuntu мы не можем поменять врем. зону просто перелинковав ф-л, в ubuntu для этого используется пакет dpkg:
dpkg-reconfigure tzdata
он запускает окно с мастером конфигурации временной зоны
---------------------------------------------------------------------------------------------------------------------

при старте системы берется значение аппаратных часов (real time clock) (хранится в схеме на мат. плате и поддерживается батарейкой)
чтобы посмотреть аппаратное время:
hwclock (hardware clock)
при запуске компа аппаратные часы передают время операционной системе
в ф-ле /etc/adjtime хранится информация о том, насколько время отличается от аппаратных часов (по умолчанию отсутствует)
создается после нескольких синхронизаций времени
чтобы подвести аппаратные часы исп. команда:
hwclock --adjust
м. указать аппаратным часам другое время:
hwclock --set --date="01/01/2020 12:00"
чтобы синхронизировать аппаратные часы с системным временем:
hwclock -w
формат UTC (universal time coordinated) универсальное время
чтобы хранить время в аппаратных часах в формате текущего часового пояса (формат LOCAL):
hwclock --localtime -w
проверим файл корректировки времени:
cat /etc/adjtime
там поменяется формат времени с UTC на LOCAL
чтобы вернуть к прежнему формату (ключ -u UTC):
hwclock -u -w
-----------------------------------------------------------------------------------------

список серверов NTP в РФ:
www.pool.ntp.org/zone/ru
для разовой настройки времени по протоколу ntp (допустим взять время с пула серверов 0.ru.pool.ntp.org):
ntpdate 0.ru.pool.ntp.org
установим демон синхронизации времени:
apt-get install ntp
его настройки лежат в /etc/ntp.conf
укажем какие сервера будем использовать, или примем сервера по умолчанию:
server 0.ru.pool.ntp.org
server 1.ru.pool.ntp.org
server 2.ru.pool.ntp.org
server 3.ru.pool.ntp.org
перезапускаем службу:
service ntp restart
(или перезагрузить конф. файл командой reload)
проверить синхронизацию с серверами точного времени м. командой (ntp query):
ntpq -pn
----------------------------------------------------------------------------

ЖУРНАЛИРОВАНИЕ СОБЫТИЙ SYSLOG
=============================

syslog сейчас уже не используется
событие в журнале записывается в формате:
источник.приоритет	куда отправлять данное событие 
его ф-л конфигурации /etc/syslog.conf
в нем например:
по умолчанию события ядра закомментированы (никуда не записываются):
#kernel.*	/dev/console
если разкомментировать будут выводиться в консоль пол-ля (на экран)
все информационные события и важнее отовсюду (*), не из почты (none), не аутентификации, не планировщика б. записываться в журнал /var/log/messages:
*.info;mail.none;authpriv.none;cron.none	/var/log/messages
все события из источника событий authpriv б. записываться в защищенный журнал /var/log/secure, просматривать его м. только пол-ль root:
authpriv.*	/var/log/secure
все события от почты б. записываться в журнал /var/log/maillog (знак - говорит о том, что этот жур-л после использования не нужно выгружать из оперативной памяти, т.е. всегда иметь его кэш в ОЗУ, система б. быстрее работать, но в сл. сбоя м. не сохраниться журнал)
mail.*		-/var/log/maillog
все события планировщика сохр. в журнал /var/log/cron:
cron.*		/var/log/cron
все источники событий emergency (черезвычайная ситуация) получит каждый пользователь (знак *):
*.emerg		*
все новости critical и выше отправлять в журнал /var/log/spooler:
uucp,news.crit		/var/log/spooler
если мы хотим чтобы только это событие записывалось ставим знак "=" после точки:
uucp,news.=crit		/var/log/spooler
локали (тэги). Это метки 0-7. можно эти метки присваивать к-либо событиям (например события загрузчика метятся local7):
local7.*		/var/log/boot.log
м. дописать все источники событий user отправлять на машину 192.168.115.118 (сервер логов):
user.*		@192.168.115.118
после этого перезапустим службу:
service syslog restart
на друго машине куда мы отправили лог., надо научить его принимать, для этого меняем его ф-л конфигурации:
/etc/sysconfig/syslog
допишем в строчку ключ -r
SYSLOGD OPTIONS="-m -r 0"
программой LOGGER м. управлять модулем системных событий
создать событие warning (предупреждение) от пол-ля написав его (Please help), отправив его т.о. на др. комп:
logger -p user.warn Please help! 
------------------------------------------------------------------------------------------------------------

РОТАЦИЯ ЛОГОВ LOGROTATE
=======================

klogd (kernel log demon) демон записи логов ядра
он м. перхватывать и регестрировать все сообщения идущие к ядру Linux
logrotate умеет сжимать логи, отправлять по почте, но основная задача брать текущий лог, сохранять его в др.место и создавать пустой ф-л
обычно это задание записывается в планировщик:
cat /etc/cron.daily/logrotate
там записано что запускается эта утилиита исп. конф. файл /etc/logrotate.conf
в нем указано:
работать с логами еженедельно (раз в неделю б. выполнять свои действия), здесь м. указать по размеру логф-ла (либо то, либо это, взаимоисключ. параметр):
раз в неделю б. сохранять текущий файл и создавать новый пустой
weekly
от какого имени будем работать с логфайлом
su root syslog
хранит 4 backlogs, т.е. 4 файла логов
rotate 4
создавать новые пустые ф-лы
create
м. раскомментировать строчку compress (сжимает, архивирует логи)
отдельное расписание ротации м. хранится в ф-ле /etc/logrotate.d
include /etc/logrotate.d
отдельные настройки ротации для отдельных лог ф-лов
/var/log/wtmp...бинарники о прошлых входах-выходах
/var/log/btmp...бинарники о ошибках входа
это ф-лы входа и выхода из системы (utmp-ф-лы текущего состояния пол-лей)
missingok если нет ф-ла -все нормально
monthly делать бэкап лога ежемесячно
создавать ф-л с такими параметрами:
create 0664 root utmp(группа владельца)
хранить 1 бэкап ф-ла
rotate 1
чтобы просмотреть ф-лы /var/log/wtmp
utmpdump /var/log/wtmp
в папке настройки для ротации отдельных служб (ф-лы с названиями служб):
/etc/logrotate.d
например cat ufw (стандартный фаервол ubuntu)
в нем:
notifempty не обрабатывать пустые ф-лы
delaycompress сжимает предыдущий ф-л при следующей ротации
sharedscripts скрипты б. выполняться один раз вне зависимости от того сколько лог ф-лов б. обработано
postrotate скрипты к. б. выполняться после rotate
смотрим какие логи создаются в папке /var/log
-----------------------------------------------------------------------------------------------------

ЖУРНАЛИРОВАНИЕ СОБЫТИЙ: JOURNALD
================================

https://www.altlinux.org/Journald
мю работать с другими системами журналирования по умолчанию (rlog,syslog,..)
файловые системы необходимые для запуска служб на ранних стадиях загрузки, выделяется место в ОЗУ и монтируются в папку /run
файловая система исп-ся как централизированное хранилище временных ф-лов в ОЗУ
/run/log/journal
в ней лежит папка e308367..., в ней хранится бинарный ф-л system.journal
по умолчанию информация держится в оперативке, чтобы она записывалась в ф-лы журналов сделаем:
настройки демона находятся в ф-ле:
/etc/systemd/journald.conf
в нем закоментированы используемые по умолчанию параметры:
#Storage=auto говорит о том, где мы будем хранить логи (в оперативке или на диске), auto - говорит о том, что он м. хранить логи на диске, если создана эта папка,
если хотим, чтобы б. создана эта папка автоматически ставим значение persistent
#Compress=yes сжимать ф-лы журнала
#Seal=yes криптография для событий journald
#SplitMode=uid разбивать ли журналы по к-либу признаку (стоит по id пол-лей)
#SyncIntervalSec=5m интервал синхронизации м/у журналами в памяти и на жестком диске (время кот-е он побыл в ОЗУи потом скидывается на диск)
#RateLimitInterval=30s и #RateLimitBurst=1000 сколько сообщений принимать, т.е. принимается max 1000 сообщений за 30 сек, остальные б. отбрасываться
ограничения для журналов на жест.диске:
#SystemMaxUse= макс. объем кот. м. занимать логи на диске
#SystemKeepFree= макс. свободного места
#SystemMaxFileSize= объем ф-ла лога, после кот. он д.б. удален с диска
тоже самое по журналу, кот. хранится в ф-ловой системе (в ОЗУ) подключенной к каталогу /run:
#RuntimeMaxUse=
#RuntimeKeepFree=
#RuntimeFileSize=
хранение по времени записи в журнале (редко исп-ся):
#MaxRetentionSec=
#MaxFileSec=imonth
отправлять ли сообщения в к-либо сторонние службы:
#ForwardToSyslog=yes
#ForwardToKMsg=no в систему отслеживания событий ядра kernel message - не отправлять
#ForwardToConsole=no
#ForwardToWall=yes команда кот. отправляет сообщение всем пол-лям
максимальные уровни сообщений, кот. будут отправляться:
#MaxLevelStore=debug
#MaxLevelSyslog=debug отладочные и выше
#MaxLevelKMsg=notice уведомления и выше
#MaxLevelConsole=info информ. и выше
#MaxLevelWall=emerg всем п-лям будет отправлять сообщения об ошибке черезвычайной ситуации и выше
поменяли значение #Storage=persistent
перезапускаем службу
service systemd-journald restart  или reload
проверяем появилась ли папка с журналом ls /var/log/journal/
e3083.... все ок
теперь инф. будет храниться не только в ОЗУ, но и на жест.диске
основные команды, которыми м. управлять journald:
journalctl (journal controller)
пишем journalctl
выводит на экран огромное к-во сообщений
чтобы просматривал сообщения от момента загрузки (boot) системы:
journalctl -b
покажи все события с 15:30:
journalctl --since 15:30
покажи все события с 15:30 до 15:38:17:
journalctl --since 15:30 --until 15:38:17
показать все сообщения со вчера до сейчас:
journalctl --since yesterday --until now
можем посмотреть отфильтровав по службе (ключ -u unit):
journalctl -u networking.service служба сети
посмотреть события ядра:
journalctl -k
посмотреть события с определенным кодом(типом) ошибки (ключ -p):
journalctl -p err
тоже с момента загрузки:
journalctl -p err -b
показать новые сообщения (последние 10):
journalctl -n
показать новые сообщения (последние 20):
journalctl -n 20
смотреть логи в режиме онлайн:
journalctl -f
посмотреть сколько места занимает журнал journalctl:
journalctl --disk-usage
установить сколько места будет занимать журнал journalctl (максимально допустимый размер хранимых на диске логов, ключ --vacuum-size, лишние ф-лы б. удаляться):
journalctl --vacuum-size=1G	1гигабайт
удаление по времени (ключ --vacuum-time)
journalctl --vacuum-time=1years  1год
если хотим, чтобы журнал journalctl отправлял логи на др. машину, то на другом компе запускаем и настраиваем службу systemd-journal-remote
для приема логов с удаленного хоста пишем например:
systemd-journal-remote --url https://ssjsj:34424
можно загружать логи с локальнной машины на удаленный хост:
systemd-journal-upload --url https://ssjsj:34424
------------------------------------------------------------------------------------------------------------------------------------------

ЖУРНАЛИРОВАНИЕ СОБЫТИЙ RSYSLOG
==============================

http://www.k-max.name/linux/rsyslog-na-debian-nastrojka-servera/

rsyslog очень производительный (обрабатывает 1млн. операций в сек.)
позволяет фильтровать по целому ряду признаков, исп. возможности протокола TCP
ubuntu использует rsyslog по умолчанию параллельно с journald:
проверим работу данной службы:
service syslog status
покажет что:
rsyslog.service -System Logging Service
Loaded: loaded (/lib/systemd/system/rsyslog.service:enabled)
Active: active(running)
опции, которые передаются демону при старте (по умолчанию пусто):
/etc/default/rsyslog
основной конфиг syslog находится:
/etc/rsyslog.conf
он разбит на 4 секции: модули, глоб. директивы (параметры)
$FileOwner syslog #права по умолчанию, кто будет владельцем
$FileGroup adm #кто будет группой владельца
$FileCreateMode 0640 #права для создания ф-лов
$DirCreateMode 0755 #права для создания папки 
$Umask 0622 #маска
$PrivDropToUser syslog #от кого будет запускаться демон
$PrivDropToGroup syslog #от какой группы владельцев запускается
$WorkDirectory /var/spool/rsyslog #очередь сообщений для обработки из ф-лов которые он будет передавать куда-то
$IncludeConfig /etc/rsyslog.d/*.conf #нужно включить конфиг из этой папки
еще бывает 2 отдельных модуля:
1. это шаблоны, где мы можем задавать формат выводимой информации
используя динамические имена ф-лов на основе к-то правила
2. правила сортировки похожи на syslogd (источник приоритет куда_выводить)
есть дополнительная фильтрация на основе скриптового языка, также фильтрация на основе св-в полученных от шаблонов
открываем папку /etc/rsyslog.d и видим 2 ф-ла конфигурации
смотрим cat /etc/rsyslog.d/50-default.conf
в нем такой же формат записи как у syslog:
auth,authpriv.*		/var/log/auth.log #источник_сообщений.тип_сообщений	куда выводить
mail.err		/var/log/mail.err #все ошибки от почты б.записываться в журнал /var/log/mail.err
смотрим ф-л для фаервола cat /etc/rsyslog.d/20-ufw.conf
в нем:
:msg,contains,"[UFW " /var/log/ufw.log #если у нас любое сообщение (:msg), содержит (contains), "[UFW " записать в журнал /var/log/ufw.log
ротация ф-лов логов прописана в файле:
/etc/logrotate.d/rsyslog
------------------------------------------------------------------------------------------------------------------------------------------

ЖУРНАЛИРОВАНИЕ СОБЫТИЙ SYSLOG-NG
================================

м.б. как единый централизованный сервер логов в сети (м. соберать логи с большого кол-ва источников и обрабатывать 600тыс/сек)
ubuntu по умолчанию исп. систему инициализации в стиле systemd и журнал ctrl (journalctl)
удалить мы этот журнал не можем
поэтому если будем ставить на ubuntu нужно сказать journalctl, чтобы он пересылал все сообщения в syslog-ng
ставим пакет:
apt-get install syslog-ng
открываем ф-л конфигурации:
vim /etc/syslog-ng/syslog-ng.conf
разбит на неск. секций
опции
источники sources, откуда он забирает сообщения (по умолч. с локальной машины) все системные (system) и внутренние (internal) сообщения
если хотим принимать сообщения по сети, то нужно разкомментировать строчки
source s_net { tcp(ip(127.0.0.1) port(1000)); }; #по какому порту и сетевой карте он будет слушать
можем указать:
source s_net { udp } #будет собирать все посылаемые ему логи по udp
далее определяем назначение destinations, в каких логах у нас будет что храниться
по умолчанию записано
destination d_auth { file("/var/log/auth.log"); }
и т.д.
есть настройки для сервера новостей INN
внизу в секции filters указано как мы будем фильтровать сообщения
filter f_dbg { level(debug); }; #будет отслеживать сообщения "отладка"  
filter f_err { level(err); };
есть сообщения
filter f_error { level(err .. emerg) ; }; #будет отслеживать ошибки и выше
можно указать фильтры по совпадению с к-либо регулярным выражением, например фильтр по хосту
Log path - пути логов
источник (s_src), заданный в первой части файла, все что попадает в этот источник и отностится к фильтру (f_auth), тоже заданный выше
будет сохраняться в назначение (d_auth):
log { source(s_src); filter(f_auth); destination(d_auth); };
в конце есть строка включить все ф-лы конфигурации из папки:
@include "/etc/syslog-ng/conf.d/*.conf*"
-----------------------------------------------------------------------------------------------------------------------------------------

DNS+DHCP
========

Мануал по настройки сетевых карт:
http://help.ubuntu.ru/wiki/настройка_сети_вручную
https://habr.com/post/137587/

сеть в ubuntu настраивается в ф-ле /etc/network/interfaces
1-й интерф. смотрит в локальную сеть:
в нем указан петлевой интерфейс loopback
и автоматический eth0 получ. адрес по dhcp:
auto eth0
iface eth0 inet dhcp
изменим на статический адрес:
auto eth0
iface eth0 inet static
address 192.168.0.1
netmask 255.255.255.0
#шлюз не указываем, он б. на 2-й сетевой карте
#укажем адрес днс-сервера
dns-nameservers 192.168.0.1
#укажем поисковый домен (имя нашей сети)
dns-search LAB.LOCAL
dns-domain LAB.LOCAL

2-й интерф. смотрит в интернет:
auto eth1
iface eth1 inet dhcp

сохраняем и перезапускаем сеть:
service networking restart

установим putty:
apt-get install openssh-server
отключим "ubuntu firewall" ufw 
ufw disable
раньше настраивался dns в папке:
/etc/resolvconf
в ней есть подпапка /etc/resolvconf/resolv.conf.d/
в ней есть ф-лы: base,head (м.б. еще tail(хвост))
в base хранится основная инф. о настройках dns
в head хранится заголовок, который вставляется перед основной инф-ией
в tail хранится инф., кот-я вставляется после этой динамически создаваемой конфигурации
сейчас ф-л head генерируется автоматически
сейчас инф-я основного ф-ла dns хранится:
/etc/resolv.conf
если не все прописалось, обновим конфигурацию dns (с ключем -u update):
resolvconf -u
если неправильно отображается инф. о dns, м. отредактировать ф-л(если его нет-создать самому):
/etc/resolvconf/resolv.conf.d/tail
если dns сервера у провайдера указаны статически, а не получаем по dhcp, запишем в файл их адреса:
nameserver 192.168.97.1
nameserver 8.8.8.8
перезапустим службу сети: service networking restart

установим пакет для dns:
apt-get install bind9
настроим основую конфигурацию сервера dns bind9
все настройки сервера лежат в папке /etc/bind
там есть ф-л с настройками 'сервер имен dns' named.conf.options
там записано
forvarders #куда переадресовывать запросы, если наш сервер не может его разрешить
по умолчанию переадресовывает в сеть интернет (0.0.0.0)
forvarders {
	0.0.0.0:
};
поменяем это значение на адрес нашего рутера (или dns-сервер провайдера)
forvarders {
	192.168.97.1:
};
dnssec - протокол к. позволяет защищать зоны dns, шифровать запросы, оставляем по умолчанию:
dnssec-validation auto;
укажем серверу через какие интерфесы слушать (listen):
listen-on {
127.0.0.1;	#слушал себя и
192.168.0.1;	#слушал интерфейс в локальную сеть
};	
#если dns сервер смотрит сразу в 2 сети (в локальную сеть и интернет) , то не нужно, чтобы он разрешал запросы, 
которые ему будут приходить из интернета, т.к. это плохо с т.зрения безопасности
стартуем сервер:
srvice bind9 start
теперь сервер б. пробрасывать запросы в рутер, даже если никаких dns серверов в настройках сети прописано не будет
шаблон зоны прямого просмотра (premier zone) хранится в БД /etc/bind/db.local
скопируем его:
cp db.local /var/lib/bind/forward.bind
отредактируем ф-л /var/lib/bind/forward.bind
в нем:
$TTL (TimeToLive) 604800 	#время которое информация записи в этой зоне будет храниться в кэше клиента, 
				#через это время удалится из кэша как неактуальная (в секундах)7дней
IN (зона интернет) - тип узлов
SOA (service of authority) - говорит о том, кто у нас явл. ответственным за эту зону и параметры этой зоны
след. значение вместо localhost указываем название нашего сервера - srv.LAB.LOCAL. root.srv.LAB.LOCAL.(
NS (name server) - тот dns-сервер, кот. отвечает за эту зону
A (тип) - запись задает соответствие имени хоста его IP-адресу (имя:IP)
AAAA - тоже самое для IP протокола версии 6
получиться:
$TTL	604800
@	IN	SOA	srv.LAB.LOCAL.	root.srv.LAB.LOCAL. (
			2		; Serial #серийный номер зоны, он б. изменяться каждый раз, когда зона б. обновляться
#это нужно если у нас за эту зону отвечает неск. серверов (на к-то сервере эта зона будет указана как дополнительная), тогда
#тот сервер у которого этот номер будет выше - будет считаться приоритетным и он будет обновлять сервера-партнеры на которых тоже есть эта зона
			604800		; Refresh #интервал обновления (как часто соседний сервер б. пытаться обновлять информацию)
			86400		; Retry #через какое время нужно повторить попытку, если пред. обновление было неудачным
			2419200		; Expire #срок годности зоны (ч/з какое время инф-я содерж. в этой зоне б.считаться недействительной на партнере, если этот партнер не связывался с основным dns-сервером)
			604800 )	; Negative Cache TTl #это время жизни несуществующих записей
;
@	IN	NS	srv.LAB.LOCAL.
@	IN	A	192.168.0.1
@	IN	AAAA	::1
srv	IN	A	192.168.0.1
добавим сюдя еще одну запись узла для проверки
test	IN	A	192.168.0.111

теперь создадим зону обратного просмотра (т.к. DNS не может в обратном порядке читать свою базу)
скопируем этот же ф-л:
cp /var/lib/bind/forward.bind /var/lib/bind/reverse.bind
в этом ф-ле нам нужно поменять указатели A на PTR (pointer указатель)
изменим файл с этой строчки:
@	IN	NS	srv.LAB.LOCAL.
1	IN	PTR	srv.LAB.LOCAL.
111	IN	PTR	test.LAB.LOCAL.

теперь серверу нужно сказать, что эти зоны у него есть
для этого меняем ф-л /etc/bind/named.conf.local
добавим в файл:
#инф. о зоне прямого просмотра
zone "LAB.LOCAL" {
	type master;				#тип зоны master (главный сервер)
	file "var/lib/bind/forward.bind";	#файл где лежит инф. о зоне
	};
#инф. о зоне обратного просмотра
zone "0.168.192.in-addr.arpa" {
	type master;
	file "var/lib/bind/reverse.bind";
	};
перестартуем службу:
service bind9 restart
проверяем статус:
service bind9 status
проверим зону прямого просмотра командой host:
host test
покажет:
test.LAB.LOCAL has address 192.168.0.111
проверим зону обратного просмотра:
host 192.168.0.111
покажет:
111.0.168..192.in-addr.arpa domain name pointer test.LAB.LOCAL.
----------------------------------------------------------------
установим dhcp-сервер:
apt-get install isc-dhcp-server
настраиваем ф-л конфигурации (если в конфиге б.хоть одна опечатка dhcp-сервер не запустится):
/etc/dhcp/dhcpd.conf
в нем:
#режим взаимодействия с dns-серверами:
ddns-update-style none;
#ложные пакеты dhcp-nack - сервер посылает эти пакеты клиенту, если клиент использует неподходящий ip-адрес
#или адрес занятый др. компом. Если в сети б. конфликтующие dhcp-сервера, то не авторитетный (authotitative)
#сервер не будет приниматься во внимание (по умолчанию эта опция отключена) 
#скажем, что этот сервер является авторитетным для этой зоны (по умолч. эта запись отсутствует)
#он м. сам вручную обрывать аренду и выдавать заново аренду IP-адресов:
authotitative;
#нам нужно настроить сеть
#по умолчанию настроена зона для всех сетей "example.org"
#option domain-name "example.org";(комментируем ее)
#option domain-name-servers ns1.example.org, ns2.example.org;(комментируем ее)
создадим отдельную зону:
subnet 192.168.0.0 netmask 255.255.255.0 {
#укажем диапазон выдаваемых адресов (нет параметра исключаемых адресов, поэтому можно разбить
#выдаваемые адреса на два пула)
range 192.168.0.101 192.168.0.199;
range 192.168.0.200 192.168.0.230;
#указываем опции (м.указать имя домена, маршрутизатор, сервер времени, днс-сервер, tftp-сервер)
option domain-name "LAB.LOCAL";
#указываем имя dns-сервера
option domain-name-servers 192.168.0.1;
#указываем маршрутизатор. адрес шлюза в интернет
option routers 192.168.0.10;
#укажем широковещательный адрес сети (не обязательно)
option broadcast-address 192.168.0.255;
}
#можем зарезервировать ip-адрес за хостом (kem118-имя хоста, 08:02:27:1c:f5:df-mac-адрес хоста)
Host kem118 {
hardware ethernet 08:02:27:1c:f5:df;
fixed-address 192.168.0.134;
}
#существует неск. локалей 0-8 (это класс системных сообщений или раздел журнала syslog)
#укажем куда будет записываться лог, по умолчанию б.записываться в систем журнал syslog и помечены, как local7
#потом мы сможем их найти по этому классу:
log-facility local7;
#параметры по умолчанию для всех зон
#сколько время аренды (сек):
default-lease-time 600;
#сколько максим. время аренды (сек):
max-lease-time 7200;
закрываем, сохраняем.
чтобы избежать получение запросов из сети интернет отредактируем ф-л:
/etc/default/isc-dhcp-server
в нем по умолчанию пусто, добавим в него по какой сетевой карте прослушивать запросы:
INTERFACES="eth0"
выходим, сохраняем
логи у нас б. вестись в syslog
для того, чтобы логи dhcp-сервера мы смотрели в отдельном ф-ле, добавим строчку в конфиг демона журналов:
vi /etc/rsyslog.conf
в конце ф-ла добавим строчку:
local7.*	/var/log/dhcpd.log
в конце ф-ла оставляем пустую строчку (т.к. некоторые конфиг. ф-лы этого требуют)
выходим, сохраняем.
теперь создадим этот файл:
touch /var/log/dhcpd.log
можно проверить посмотреть права на этот ф-л и м. ли демон туда писать
stat /var/log/dhcpd.log
покажет:
Access: (0644/-rw-r--r--) Uid:(0/root) Gid:(0/root)
нужно поменять владельца на syslog и группу владельцев на adm
(подсмотрели права на другие логи из папки /var/log/)
chown syslog:adm /var/log/dhcpd.log
перегружаем сервис rsyslog:
service rsyslog restart
перегружаем сервис dhcp:
service isc-dhcp-server restart
проверяем его статус:
service isc-dhcp-server status
м. показать ошибку (она может не мешать):
Can't create PID file /run/dhcp-server/dhcpd.pid: Permiss..ied
посмотрим адреса аренды:
cat /var/lib/dhcp/dhcp.leases
должны появиться записи после получения адресов
проверим файл логов dhcp:
cat /var/log/dhcpd.log

чтобы копировать куски текста в буфер обмена установим putty на комп с Windows и подключимся ч/з него
запустим команду для генерации ключа:
dnssec-keygen -a HMAC-MD5 -b 128 -r /dev/urandom -n USER DHCP_UPDATER
где
dnssec-keygen работает с dnssec (технология защиты dns, позволяет нам подтверждать информ-ю о подлинности записи на сервере dns)
-a алгоритм (HMAC-MD5)
-b размер ключа (128 бит)
-r устройство отвечающее за генерацию чисел (в ubuntu это /dev/urandom)
-n тип владельца ключа (м.б. ключ для подписи зоны, подписи хоста, мы создаем ключ DHCP_UPDATER для пол-лей)
покажет:
Kdhcp_updater.+157+38479
появятся ключи в папке пол-ля:
Kdhcp_updater.+157+38479.key и Kdhcp_updater.+157+38479.private
откроем ф-л Kdhcp_updater.+157+38479.private
покажет:
Private-key-format: v1.3
Algoritm: 157 (HMAC_MD5)
Key: xR+zsn0k0i+va9IwoSCnzg==
Bits: AAA=
Created: 20150921095641
Publish: 20150921095641
Activate: 20150921095641
пропишем данный ключ в конфигурации dns-сервера  и dhcp-сервера
зайдем в ф-л конф. сервера dns:
vi /etc/bind/named.conf.local
добавим в начало ф-ла информ-ию о ключе, кот-й б.использоваться для обновления инф-ии в зонах прямого и обратного просмотра

key DHCP_UPDATER {
	algoritm HMAC-MD5.SIG-ALG.REG.INT; #алгоритм с пом. которого гинерировали ключ
	secret "xR+zsn0k0i+va9IwoSCnzg=="; #вставили сам ключ
	};
#теперь допишем в каждую зону конф. ф-ла данный ключ
#инф. о зоне прямого просмотра
zone "LAB.LOCAL" {
	type master;				#тип зоны master (главный сервер)
	file "var/lib/bind/forward.bind";	#файл где лежит инф. о зоне
	allow-update { key DHCP_UPDATER; };
	};
#инф. о зоне обратного просмотра
zone "0.168.192.in-addr.arpa" {
	type master;
	file "var/lib/bind/reverse.bind";
	allow-update { key DHCP_UPDATER; };
	};
выходим,сохраняем
рестартуем службу:
service bind9 restart
теперь скажем dhcp-серверу, что сам dhcp может обновлять dns
для этого зайдем в ф-л конфигурации сервера dhcp:
vi /etc/dhcp/dhcpd.conf
допишем в начале ф-ла:
ddns-updates on; #разрешаем обновлять зоны dns
ddns-update-style interim; #изменим стиль обновления на interim
update-static-leases on; #разрешать обновлять статические адреса аренды
authoritative; #оставим

key DHCP_UPDATER {
	algoritm HMAC-MD5; #алгоритм шифрования без дополнений
	secret "xR+zsn0k0i+va9IwoSCnzg==";
	} #в конфигураторе dhcp ; не ставим
#а также добавим информацию о зонах
zone LAB.LOCAL {
	primary 192.168.0.1;
	key DHCP_UPDATER;
	}
zone 0.168.192.in-addr.arpa. {
	primary 192.168.0.1;
	key DHCP_UPDATER;
	}
сохраняем,выходим
перестартуем службу dhcp:
service isc-dhcp-server restart
проверим наличие журналов
ls /var/lib/bind
видим журналов нет
бывает так, что они появляются не сразу и нужно перезапускать сервер.
бывает так, что службы стартуют и некоторое время им нужно поработать, чтобы журналы появились
service isc-dhcp-server status
показал, что служба не работает 'active=failed'
просмотрим лог журнала 
tail -n 30 /var/log/syslog
видим запись, ошибка в 13 строке:
Sep 21 13:02:29 srv sh[12054]: /etc/dhcp/dhcpd.conf line 13: semicolon expected.
исправили рестартуем сервер:
service isc-dhcp-server restart
опять проверим наличие журналов (появляются после первого запроса аренды ip адреса)
ls /var/lib/bind
появились ф-лы forward.bind.jnl и reverse.bind.jnl
проверяем ф-л аренды ip-адресов dhcp-сервера:
cat /var/lib/dhcp/dhcpd.leases
проверим ф-л лога dhcp-сервера:
cat /var/log/dhcpd.log
проверяем получение новой информации в зонах (появится после рестарта службы dns: bind9):
cat forward.bind
-----------------------------------------------------------------------------------------------

СОЗДАЕМ ТРЕКЕР ЗАЯВОК
=====================
Крупные системы:
Системы ITSM (IT Servece Managment)
Системы попроще:
Системы ServiceDesk (автоматизация работы службы тех.поддержки)
Системы еще проще:
Системы HelpDesk (автоматизация обработки запросов) #трекер заявок

АГЕНТ ПЕРЕДАЧИ ПОЧТЫ (MTA) POSTFIX
==================================

по сертификатам: https://habr.com/company/tuthost/blog/150433/
варианты релеев  на разных хостерах: http://sys-adm.org.ua/mail/postfix-sender-dependent-relayhost

Если уже установлен sendmail - его нужно отключить.
устанавливаем пакет postfix:
#На debian потребовалось также установить пакет: apt-get install libsasl2-modules чтобы всё заработало
apt-get install postfix
при установке выбираем конфигурацию Satellite system (просто для отправки почты через к-то узел)
также есть возможность выбрать конфигурации:
Internet Site (полноценный почтовый сервер) 
Internet with smarthost (получает почту сам, а отправляет черз к-то узел)
(все почта отправляется внутри узла, без выхода в сеть)
потом в случае чего в любой момент сможем запустить программу dpkg-reconfigure для запуска мастера настройки
или отредактировать конф. файл
в мастере установки указываем:
1.имя хоста
укажем ubsrv
2.сервер используемый для редиректа
как наз-ся сервер для отправки писем стороннего почтового сервера (mail.ru, gmail) и порт
укажем smtp.gmail.com:587

установим утилиты при пом. которых будем проверять работу почтового сервера (для отправки письма):
apt-get install mailutils
откроем файл конфигурации postfix:
vi /etc/postfix/main.cf
в нем
нужно убедиться, что указан relayhost:
relayhost = smtp.gmail.com:587
можно убрать ipv6 адреса из конфигурации
добавим опцию использования протокола SASL (simple authentication security layer):
smtp_sasl_auth_enable = yes
#укажем откуда брать пароль почты (храним в отдельном ф-ле для безоп-ти)
smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd
#не пускать никого анонимно на этот сервер
smtp_sasl_security_options = noanonymous
#файл в котором будут лежать доверенные центры сертификации
smtp_tls_CAfile = /etc/postfix/cacert.pem
#указываем, что smtp будет отправляться с использованием tls
smtp_use_tls = yes
сохраняем, выходим
теперь нужно создать ф-л с логином и паролем:
vi /etc/postfix/sasl_passwd
запишем в нем:
smtp.gmail.com:587	mberdyugin@gmail.com:наш_пароль
сохраняем, выходим
теперь сменим права на файл (доступ только у su и только на чтение):
cmod 400 /etc/postfix/sasl_passwd
загружаем этот файл в postfix с пом. команды postmap (исп. для создания и изменения ф-лов конфигураций):
postmap /etc/postfix/sasl_passwd
в папке /etc/ssl/serts лежит куча сертиф-ов, среди них лежит сертификат, 
который явл. центром сертификации для серт-ов вида X.509 (если мы говорим, что доверяем ему - мы автомат. доверяем большинству защищенных серверов в интернете)
/etc/ssl/certs/Thawte_Premium_Server_CA.pem
скопируем его в наш ф-л указанный в конфигурации postfix:
cat /etc/ssl/certs/Thawte_Premium_Server_CA.pem | sudo tee -a /etc/postfix/cacert.pem
рестартуем сервис:
service postfix restart
отправим проверочное письмо:
echo "Test Letter Number 1" | mail -s "Test 1" 1c@mail.ru
посмотрим логи:
tail /var/log/mail.log
на gmaile нужно разрешить доступ к почт. ящику из непроверенных приложений (разрешаем):
https://myaccount.google.com/lesssecureapps
смотрим последние 4 сообщения лога:
tail -n 4 /var/log/mail.log
---------------------------------------------------------------------------------------------------------------------------------------------------------------
выбор системы: https://toster.ru/q/44724
внедрение каяко: https://habr.com/company/plarium/blog/220585/

отключаем фаервол ubuntu, чтобы не мешал:
ufw disable
чтобы удаленно подключаться через Putty устанавливаем ssh-сервер:
apt-get install openssh-server
обновляем список репозитория:
apt-get update
ставим обновления на ubuntu:
apt-get upgrade
установим mysql-сервер, mysql-клиент, необходимые для этого библиотеки:
apt-get install mysql-server mysql-client libmysqlclient-dev
в мастере установки указываем пароль для юзера "root" MySQL (достаточно 4 символа)
отредактируем ф-л конфигурации mysql:
vi /etc/mysql/mysql.conf.d/mysqld.cnf
добавим параметр увеличенный размер кэша:
#рекомендуется выставлять в размере половины ОЗУ сервера
innodb_buffer_pool_size = 2048M
запустим мастер, который обезопасит установку:
mysql_secure_installation
попросит ввести пароль от п-ля root MySQL-сервера
спрашивает хотим ли мы изменить пароль, ставим "n"
спрашивает удалить анонимных пол-лей: "y"
запретить удаленно подключаться: "y"
удалять ли тестовую БД: "y"
перезагрузить таблицу привелегий: "y"
рестартуем сервис mysql:
service mysql restart
теперь разберемся с сервером WEB
установим следующие пакеты:
apt-get install make apache2 libapache2-mod-fcgid libssl-dev libyaml-perl libgd2-xpm-dev libgd-gd2-perl libgraphviz-perl
make - утилита для преобразования ф-лов из одной формы в другую (компилировать исходный код)
добавим пол-ля rt, создадим одноименную группу, добавим пол-ля в эту группу:
adduser --system --group rt
добавим юзера rt в группу www-data (apache):
usermod -aG rt www-data
--------------------------------------------------------------------------------------------------
для установки трекера заявок скачаем установочный пакет с офиц. сайта https://www.bestpractical.com
Мануал по конфигуратору: https://docs.bestpractical.com/rt/4.2.15/configure.html
Русскоязычная статья неплохая: https://habr.com/sandbox/96505/
Лучший мануал (англ): http://binarynature.blogspot.ru/2013/10/install-request-tracker-4-on-ubuntu-server.html
для начала обнофим информацию о репозиториях:
apt-get update
проверяем установлен ли perl и make:
apt-get install perl
apt-get install make
мы сейчас будем компилировать свой request tracker используя его конфигурационные ф-лы.
для этого есть спец. make-фйлы, которые запускают последовательности команд, подкачивают зависимости
приступаем к скачке с сайта пакета трекера с пом. команды wget:
wget https://download.bestpractical.com/pub/rt/release/rt-4.2.12.tar.gz
по умолчанию ф-л скачивается в домашнюю папку пол-ля, распакуем во временную директорию:
tar xzvf rt-4.2.12.tar.gz -C /tmp
где:
-x extract (распаковать)
-z использовать gzip
-v (verbose) показывать что происходит
-f (file) куда выводить
-C распакует в папку
после перезагрузки системы из папки /tmp все сотрется
в этой папке появилась папка /tmp/rt-4.2.12
переходим в эту папку и запускаем конф. ф-л с параметрами:
./configure --with-web-user=www-data --with-web-group=www-data --enable-graphviz --enable-gd
где:
--with-web-user от кого запускаем (пол-ль от которого работает web-сервер apache "www-data")
--with-web-group от группы пол-лей
--enable-graphviz пакет graphviz (в нем много утилит ком. строки и GUI программ, нужен чтобы создавать графы и строить разл. зависимости)
--enable-gd пакет связанный с графикой и диаграммами
теперь сконфигурируем библотеку модулей span:
cpan
разрешить конфигурирование автоматически: "y"
пускает в оболочку конфигурации
зададим изначально установку зависимостей (зададим "ставить по умолчанию"), в оболочке пишем:
o conf prerequisites policy follow
модули, которые нужны для установки, но потом не нужны в системе
зададим политику по умолчанию, ставить все модули  которые нам нужны для build-a текущих пакетов и пусть они у нас остаются в системе:
o conf build_requires_install_policy yes
для того, чтобы эта конфигурация применилась напишем:
o conf commit
выходим из оболочки буквой "q"
проверим текущую конф-ю для настройки rt:
make testdeps
для доустановки недостающего, запускаем утилиту фиксирования найденных проблем:
make fixdeps
#процесс м. затянуться на 30мин
в ходе установки возник вопрос, установить модуль XS Stash "Do you want to build the XS Stash module?", отвечаем "y"
Do you want to use the XS Stash by default? ставим тоже "y"
(возможно этот  пакет придется скачивать и устонавливать вручную через wget)
(д.б. доступ к интернету)предлагает провести доп. тесты "Do you want to run the live tests (y/N)?" ставим тоже "y"
еще раз проверим, все ли у нас установилось:
make testdeps
если опять чего-нибудь не найдет (missing) - опять запустим make fixdeps
если все found, то м. выполнять действие установки:
make install
необходимо инициализировать БД:
make initialize-database
запрашивает пароль от п-ля root от mysql
теперь нужно настроить apache (в данный м. при переходе на наш ip-адрес отображается страница по умолчанию apache)
переходим в папку доступных ф-лов apache:
cd /etc/apache2/sites-available/
ls
видим 2 ф-ла:
000-default.conf - конфигурация по умолчанию для стартовой страницы
default-ssl.conf - конфигурация по умолчанию для доступа через ssl
отредактируем ф-л 000-default.conf8 для доступа через http :
#допишем имя сервера
ServerName rt.ubsrv:80
#добавим блок для работы трекера
AddDefaultCharset UTF-8
DocumentRoot /opt/rt4/share/html #директория куда по умолчанию установился трекер - /opt/rt4/
Alias /NoAuth/images/ /opt/rt4/share/html/NoAuth/images/
ScriptAlias / /opt/rt4/sbin/rt-server.fcgi/
<Location />
Require all granted
</Location>
закомментируем строчки:
#ServerAdmin webmaster@localhost
#DocumentRoot /var/www/html
сохраняем,выходим
перезапускаем apache:
service apache2 restart
если стартанул без ошибок
заходим на нашу страницу через браузер, видим что все заработало
по умолч. логин root, пароль: который_мы_задавали (password)
---------------------------------------------------------------------------------------------
Полный мануал по всем возможностям: https://docs.bestpractical.com/rt/4.4.3/index.html
Опции для файла RT_SiteConfig.pm: https://docs.bestpractical.com/rt/4.4.3/RT_Config.html

откроем ф-л конфигурации:
/opt/rt4/etc/RT_SiteConfig.pm
добавим здесь базовые настройки:
Set($rtname,'rt.it-semaev.ru'); #имя rt, желательно, чтобы совпадало с внешним именем
Set($Organisation, 'rt.it-semaev.ru');
Set(@ReferrerWhitelist, qw(10.0.1.8:80); #лист с которого б.разрешено обращаться к нашему rt
Set ($Timezone, 'Europe/Moscow');
Set($LogoLinkURL, 'http://it-semaev.ru'); #ссылка на логотип
сохраняем и перегружаем apache:
service apache2 restart
остальные настройки уже делаем через браузер
---------------------------------------------------------------------------------------------
Мануал по модулю: https://metacpan.org/pod/RT::Authen::ExternalAuth
Пример внедрения: http://trevthorpe.blogspot.ru/2015/01/request-tracker-424-ldap-authentication.html
установим модули для внешней аутентификации:
cpan -i RT::Authen::ExternalAuth
модуль для импорта из службы каталогов:
cpan -i RT::Extension::LDAPImport
отредактируем ф-л конфигурации /opt/rt4/etc/RT_SiteConfig.pm
добавим записи:
Set(@Plugins, qw(RT::Extension::LDAPImport)); #подключим плагин
#добавим опции к плагину
Set ($LDAPHost,'dc.mti.local'); #имя контроллера домена
Set ($LDAPUser,'mti\rt'); #пол-ля от имени кот-го будем просматривать наш домен
Set ($LDAPPassword, '1000'); #пароль пол-ля
Set ($LDAPBase, 'dc=mti,dc=local'); #каталог в АД из которого б.импортировать пол-лей
Set ($LDAPFilter, '(&(objectClass=person))'); #фильтр импорта только людей
Set ($LDAPMapping, {	Name	=> 'sAMAccountName'), #имя импортируемого пол-ля
			RealName	=>'cn', #реальное имя пол-ля
			EmailAddress	=> 'mail'}); #брать email адрес пол-ля
Set ($LDAPCreatePrivileged, 1); #привелегированные права пол-ля
Set ($LDAPUpdateUsers, 1); #обновлять инф-ю о пол-лях при запуске импорта
сохраняем,выходим
запустим тестовый импорт:
/opt/rt4/local/plugins/RT-Extension-LDAPImport/bin/rtldapimport \
> --debug > ldapimport.debug 2>&1
#создаст в папке, в кот-й мы находимся ф-л ldapimport.debug
теперь запустим импорт:
/opt/rt4/local/plugins/RT-Extension-LDAPImport/bin/rtldapimport \
> --import
добавим в ф-л конфигурации еще плагин аутентификации:
Set (@Plugins, qw(RT::Authen::ExternalAuth RT::Extension::LDAPImport)); #добавим в эту строчку
#а также настройки плагина, в принципе поль-ли м.создаться только с этим плагином, без импорта 
Set ($ExternalAuthPriority, [ 'My_AD' ]); #куда он будет передавать запросы аутентификации ('My_AD' псевдоним источника)
Set ($ExternalAuthPriority, [ 'My_AD' ]); #если есть альтернатива от куда еще качать
Set ($UserAutocreateDefaultsOnLogin, { Priveleged => 1 }); #привелегированные права пол-ля
Set ($ExternalSettings, {
	'My_AD'		=> {
	'type'		=> 'ldap',
	'server'	=> 'dc.mti.local',
	'user'		=> 'mti\rt',
	'pass'		=> '1000',
	'base'		=> 'dc=mti,dc=local', #от куда берем пол-лей
	'filter'	=> '(objectClass=person)',
	'attr_match_list'	=> ['Name'], #аттрибут как пол-ль м.аутентифицироваться (по имени 'login')
	'attr_map'	=> {			#указываем, что за параметр 'Name'
	'Name'		=> 'sAMAccountName',
	'EmailAddress'	=> 'mail',
	'RealName'	=> 'cn',
	},
	},
} );
сохраняем,выходим
рестартуем apache:
service apache2 restart
для проверки в АД создадим пол-ля, которого не было при импорте
проверяем вход в трекере
---------------------------------------------------------------------------------------------------------------------------
ou - organisation unit
cn - canonical name
Настроим аутентификацию через apache
Мод базовой аутентификации: https://httpd.apache.org/docs/2.4/mod/mod_auth_basic.html
Мод ldap аутентификаци: http://httpd.apache.org/docs/current/mod/mod_authnz_ldap.html
Разные опции RT: https://docs.bestpractical.com/rt/4.4.1/RT_Config.html
зайдем в конфиг зайта по умолчанию apache:
/etc/apache2/sites/available/000-default.conf
для того, чтобы apache м.авторизовывать пол-лей нужно изменить строчку Require all granted на:
Require valid-user #пол-ли д.б. настоящие, т.е. могли авторизоваться
AuthType Basic #тип аутентифик. базовый
AuthName "Request Tracker" #какая строчка б. показана браузером
AuthBasicProvider ldap
AuthLDAPURL "ldap://192.168.0.1/dc=mti,dc=lan?sAMAccountName?sub?(objectClass=*)"
# IP dc(м. имя)/basedn(откуда искать пол-лей)?что ищем у по-лей(sAMAccountName)?sub(пробираемся в глубь дерева)?класс объекта поиска=*(м.поставить person)
#след.строка от имени кого б. проверять, т.к. АД не умеет пускать анонимных п-лей поэтому создадим пол-ля connect в корне домена
AuthLDAPBindDN "cn=connect,dc=mti,dc=lan" 
AuthLDAPBindPassword "1000" #пароль п-ля connect
сохраняем,выходим
включаем еще модуль:
a2enmod authnz_ldap
рестартуем apache:
service apache2 restart
чтобы после авторизации apache еще не было авторизации web, нужно открыть ф-л конфигурации rt:
/opt/rt4/etc/RT_SiteConfig.pm
в конец добавим опцию, кот-я позволит пол-лю авторизоваться:
Set ($WebRemoteUserAuth, 1); #позволит передавать apache инф. об успешном логировании rt
#теперь при входе на rt не б. пускать п-ля root, чтобы это исправить нужно покопаться в apache

